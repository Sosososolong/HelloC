=========================================================================
1.p[i]和*(p+i)相同
const修饰的结构体指针变量: 变量能修改, 但是指针指向的内存不能修改

2.windows平台的文本换行符"\r\n"
====hello world====
111
222
333

Linux平台的文本换行符"\n"
在windows平台下以文本方式打开文件: 读取文件, 会将"\r\n"换成"\n", 写入文件的时候, 会将"\n"换成"\r\n"
如果以二进制方式打开文件, 那么就不会有上面的转换过程

3.数组在函数间的传递, 注意实参类型(数组), 形参类型(指针)
int a[] = {2, 10, 8, 7, 5, 4, 1, 3, 6, 9};
int n = sizeof(a)/sizeof(a[0]);
// 这里的实参a是数组类型, choose_sort()的第一个参数(形参)是指针类型, 参数传递过程实际上是
// 数组(a)复制了一份赋值给a, 而不是把地址传递过去了
choose_sort(a, n);

4.4个字节大小的内存空间叫做整型

5.字符'\0'和数字0是等价的

6.char str[] = "abc"; // str是首地址,常量,不能作为指针使用,"abc"在文字常量区拷贝一份到栈区
  char *str = "abc"; // str是指针, 直接指向文字常量区的"abc"

7.栈的生长方向,递减,从高地址往低地址分配,首地址在低位(指针进行加法运算得到首地址后面的内存), 后进先出, 堆相反

fgets() 
1.从文件中(参数3:文件指针,文件可以是设备文件or磁盘文件) 读取一定长度的字节(参数2: int) 存放到内存的字节数组中(参数1: char *)
2.当参数3是stdin的时候(关联键盘的设备文件), 直到键盘输入回车, 从而从键盘读取输入的一行内容

fputs()
1.将一个字符串(参数1: char *)写入到一个文件指针(参数2: FILE */stdout)所关联的文件中(磁盘文件or设备文件)

sscanf()
1.有点类似于拆包,将一个字符串中的字符按类型以一定的格式提取出来赋值给新的变量(从字符串中获取字节)
char buf[100] = "1+2=\n";
int a, b;
char ch;
sscanf(buf, "%d%c%d=\n", &a, &b, &ch);

fprintf()
1.以格式化的方式将字符数组(参数2)放到文件中(FILE *)



a=0;
a++ && aa++;
a=?

========================================================================

===================================指针=====================================
只有使用“&数组名”时，才是取数组首地址；直接打印数组名或者&数组名[0]都是取得数组首元素地址
"&数组首元素变量名"结果是变量的地址(此变量占据的是数组之外的另外一块内存空间)

char *tmp;
char **p = &tmp;  //ok

//str首元素 是什么类型？ char *
//&str[0], 代表首元素地址，str等价于&str[0](数组名字就是数组首元素地址)
char *str[] = {"abc", "micke", "hello"}; //数组每一项都是char *类型（"abc"就是"abc"首元素地址）
char **p = str;  //char **指向char *
char **p = &str[0]

//下面三者等级， 编译器都当做char **p处理， 形参中的数组都是指针(数组名为元素首地址)，不是数组
void fun(char **p);
void fun(char *p[]);
void fun(char *p[100]);

void fun(int a[]);
void fun(int a[100]);
void fun(int *a)

//p2是数组
char *p2[] = {"abc", "mike", "hello"}
//p2是指针
char * * p2;

===================================静态的局部变量=====================================
存储在"data区"(函数中的局部静态变量在函数调用前就分配空间了,程序结束前不会释放)
初始化语句(static int a = 0;)只会执行一次,但是可以赋值多次    ****
只能用常量初始化(不要用变量给它赋值,因为变量只有程序执行到才会给变量分配空间,而它一开始就分配了空间) ****
在编译阶段就已经分配内存空间,函数没有调用前它就已经存在
如果没有被初始化,默认值为0(普通局部变量是随机数)

===================================普通全局变量=====================================
在定义之前若要使用可以声明(extern int a;) 可以声明多次, extern为声明的关键字
    extern int b = 10; //err,只有声明,没有定义,无法给变量赋值
在编译阶段已经分配空间(函数没有执行前),只有在整个程序结束才自动释放

缺陷:
    如果定义一个全局变量,没有赋值(初始化),无法确定是定义还是声明
    如果定义一个全局变量,同时初始化,这个肯定是定义

=================================声明一个全局变量=====================================
定义在函数外面,其他文件也都能用,一个全局变量多个文件中只能定义一次
如果要使用另一个.c文件中定义的全局变量, 需要声明一下,虽然可以不用extern,带上extern比较清晰
extern int a;
这种方式可行,但是使用头文件的方式(声明所有的变量和函数)更加优秀

=================================声明一个函数=========================================
//假设想要调用另一个.c文件中的一个test()函数,需要声明,声明的时候有没有extern无所谓
extern void test(); 或者 void test();
这种方式可行,但是使用头文件的方式(声明所有的变量和函数)更加优秀

=================================全局静态变量=========================================
跟普通的全局变量相比,作用域不一样(文件作用域)
extern关键字只适用于普通全局变量

一个文件有且只有一个static全局变量的定义
static全局变量只能在当前文件中使用

=================================内存分区/内存四区=========================================
gcc编译器:
    1.预处理,头文件展开,宏定义展开,条件编译,去掉注释
    2.编译,生成汇编代码
    3.生成目标代码.o
    4.关联链接,生成可执行程序
生成a.out文件, 终端:size a.out
    text    data    bss     dec     hex     filename
    1099    544     8       1651    673     a.out

a.说明编译生成可执行程序后,程序执行前,就已经"确定"(并没有加载到内存)了这几个 内存分区,虽然分区确定了,但是没有加载内存
程序只有运行时才会加载内存:
    text(代码区): 只读,函数
    data: 初始化的数据,全局变量和静态变量, 文字常量区(只读)
    bss: 没有初始化的数据,全局变量和静态变量
b.当运行程序,加载内存,首先根据前面确定的内存分区(text,data,bss)先加载, 然后额外加载两个区
    text(代码区): 只读,函数
    data: 初始化的数据,全局变量和静态变量, 文字常量区(只读)
    bss: 没有初始化的数据,全局变量和静态变量
    stack(栈区): 普通局部变量
    heap(堆区): 手动申请空间,手动释放, 整个程序结束,系统也会自动回收,如果没有手动释放,程序也没有结束
        这个堆区空间不会自动释放


堆区(heap): Malloc/new free/delete, 操作系统管理
栈区(stack): 程序局部变量
    char str[] = "abcd"; // 现在文字常量区放一个"abcd\0", 然后拷贝一份到栈区"abcd\0"
全局区(global): 常量和全局变量, 操作系统管理
    全局变量
    静态变量
    文字常量区
代码区(code): 操作系统管理



=================================打字游戏=========================================
1.生成随机字母('a'+0~25)

// 用随机字母填充字符数组, 字符数组的总长度(包含结束符)为宏定义MAX(51个)
// str 需要填充的字符数组的首地址 
void fill_char_array_with_rand_char(char *str)
{
    srand((unsigned int)time(NULL)); //随机种子
    int i = 0;
    for (i = 0; i < MAX - 1; i++)
    {
        // rand() % 26, 得到0~25的一个随机数
        *(str + i) = rand() % 26 + 'a';
    }

    *(str + MAX - 1) = '\0';
}


=================================结构体=========================================
struct Student
{
    char name[50];
    int age;
    int score;
};
类型名: struct Student; (别忘了struct)
变量名: struct Student stu;
//stu.name = "mike"; //error, 因为数组名是常量, 只读
strcpy(stu.name, "mike");
stu.age = 18;
stu.score = 60;

只有定义的时候才能初始化:
struct Student stu2 = {"mike", 18, 60};

如果是指针变量, 使用"->":
struct Student *p;
p = &stu2; //指针有合法指向, 才能操作结构体成员
strcpy(p->name, "mike");
p->age = 18;
p->score = 99;

任何结构体变量都可以用"."或者"->"操作成员
(&stu2)->age = 18; //求得变量的指针(地址)时用 "->"
(*p).age = 18; //通过指针前加"*", 直接操作结构体内存空间时用"."

相同类型的2个结构体变量可以相互赋值
struct Student s1 = {"mike", 18, 88};
struct Student S2;
s2 = s1; //值传递, 两个变量是没有关系的独立内存

指针指向堆区空间
struct Student *p;
p = (struct Student *)malloc(sizeof(struct Student));
if(p == NULL){
    printf("malloc error\n");
    return 0;
}   
...
if(p != NULL){
    free(p);
    p = NULL;
}


成员指向data区或者栈区或者栈区
struct Student{
    int age;
    char *name;
    int score;
};
int main(){
    struct Student s;
    s.age = 19;
    s.name = "mike"; // 指针变量保存字符串常量的首地址, 相当于char *p = "mike"; "mike"在文字常量区
    // char buf[100];
    // s.name = buf; //指向栈区空间
    // strcpy(s.name, "mike");

    // s.name = (char *)malloc((strlen("mike") + 1) * sizeof(char));  // 指向堆空间
    // strcpy(s.name, "mike");
    
}


=================================共用体(联合体)=========================================
union Test{
    unsigned char a;
    unsigned short b;
    unsigned int c;
    double d;
};

int main(){
    // 1.共用体的大小为最大成员的大小
    printf("%lu\n", sizeof(union Test)); // 8(double的长度)
    // 2.共用体公用一块内存, 所有成员的地址一样(首地址相同)
    union Test obj;
    printf("%p, %p, %p, %p\n", &obj, &ojb.a, &obj.b, &obj.c, &obj.d); //打印出的所有地址都相同
    
    // 3.给某个成员赋值, 会影响到另外的成员
    // 左边是高位, 右边是低位
    // 高位放高地址, 低位放低地址(小端)
    obj.c = 0x44332211; (16进制可以为每个字节赋值, 每两个16进制占一个字节, 因为一个字节8位,二进制最大能存储255个值,而两位的16进制最大数也是255)
    printf("obj.c = %x\n", obj.c); // 44332211 
    printf("obj.a = %x\n", obj.a); // 11
    printf("obj.b = %x\n", obj.b); // 2211

    obj.a = 0xaa;
    printf("obj.c = %x\n", obj.c); // 443322aa
    printf("obj.a = %x\n", obj.a); // aa
    printf("obj.b = %x\n", obj.b); // 22aa


}


=================================枚举 enum=========================================
主要作用是替代如下定义宏的方式:
#define MAX 51  // 定义宏
#define pink 0
#define red 1
#define green 2
#define white 3
#define yellow 4

枚举的方式:
// 里面的成员是一个标识符, 枚举常量
// 第一个成员如果没有赋值, 默认为0, 下一个成员比上一个多1
enum Color
{
    pink, red, green, white, yellow
};


=================================文件 概述=========================================
printf(); // 把内存中的值显示(写)到屏幕  
过程:
内存->缓冲区(存满一次提交)->屏幕(文件?)

scanf(); 
键盘(文件?)->缓冲区->内存变量

FILE 所有平台名字都一样, FILE是一个机构提类型, 里面的成员功能一样,不同平台成员的名字不一样.
FILE *fp
1. fp指针, 只调用了fopen(), 在堆区分配空间, 把地址返回给fp
2. fp指针不是指向文件, fp指针和文件关联, fp内部成员保存了文件的状态
typedef struct
{
    short level; //缓冲区"满"后者"空"的程度
    unsigned flags; //文件状态标识
    char fd; //文件描述符(其实就是一个整型)
    unsigned char hold; //如无缓冲区不读取字符
    short bsize; //缓冲区的大小
    unsigned char *buffer; //数据缓冲区的位置
    unsigned ar; //指针, 当前的指向
    unsigned istemp; //临时文件指示器
    short token; //用于有效性的检查
}

3. 不能直接对fp指针进行操作, 必须通过文件库函数来操作fp指针

4. 通过库函数操作fp指针, 对文件的任何操作, fp里面成员会相应的变化(系统自动完成)


=================================文件 分类(磁盘文件和设备文件)=========================================
磁盘文件
指一组相关数据的有序集合, 通常存储在外部介质(如磁盘)上, 使用时才调入内存
设备文件
在操作系统中, 把每一个与主机相连的输入/输出设备看做是一个文件, 把它们的输入输出等同于对磁盘文件的读和写


=================================文件 操作流程=========================================
1. 打开文件fopen()
2. 读写文件
    1) 按字符读写fgetc(), fputc()
    2) 按字符串(行)读写文件fgets(), fputs()
    3) 文件结尾判断 feof()
3. 关闭文件


读写文件, 需要fp指针(FILE *)结合相关库函数使用才行, fp指针指向的内存空间记录了目标文件的相关信息, printf()函数其实是针对屏幕的, 而屏幕也可以看做一个文件,
与屏幕也有个相关的"fp指针"(FILE *), 叫做"stdout", 将"stdout"关联到一个磁盘文件, 那么即可对磁盘文件进行操作

理解性代码(不用于执行)
printf("before aaaaa\n");  //内存中已经加载了文件相关信息的"stdout"指针, 通过"stdout"向屏幕写入字符串
fclose(stdout); //切断了"stdout"指针(FILE *)指向
stdout = fopen("./01.txt", "w"); //fopen()打开一个文件, 并返回"FILE *"类型的指针赋值给"stdout"
if(stdout == NULL)
{
    // 打开文件失败
    printf("fopen error!");
    return -1;
}
// "stdout"指针指向的内存区域已经关联到了"01.txt"文件, 所以此代码的意图是写入字符串到"01.txt"文件中
// 然而这里只是帮助我们理解磁盘文件和设备文件的区别的代码, 并不能执行成功!!!!
// 实际思路一样的, 但是更改指针指向和打开文件的库函数有所不同
printf("after bbbbbb\n"); 

系统编程的代码思路:
printf("before aaaaaa\n"); // printf()函数的作用是往"1"代表的设备(标准输出设备)中写内容
close(1);  // "1"是文件描述符 本来代表标准输出设备(屏幕), 关闭"1"就切断了"1" 和 "屏幕"的关联, "1" 处于空闲状态
int fd = open("01.txt", O_WRONLY, 0777); //打开文件, 并返回一个最小可用的 "数字"(即"1"), "数字fd"代表"目标文件"
printf("after bbbbbb\n"); // 此时"1"代表"01.txt"文件,而printf()会往"1"中写入字符串,所以字符串被写入"01.txt"文件中





=================================文件 打开和关闭=========================================
FILE * fopen(const char *filename, const char * mode)

此函数在堆空间开辟一块内存空间, 存储了FILE结构体, FILE结构体中的成员记录了目标文件的状态, 最后函数返回FILE结构体的
内存地址, 即FILE *类型的fp

代码:
FILE *fp = NULL;
// "w", 如果文件不存在, 新建, 如果文件存在,清空再打开
// "r", 如果文件不存在, 打开失败
// "w+", 读写模式, 清空文件再打开
// "a", 如果文件不存在, 新建, 如果文件存在,不清空内容,光标自动放在文件末尾
fp = fopen("./02.txt", "r");
if(fp == NULL){
    perror("fopen");
    return 0;
}


fclose(fp);
fp = NULL;
return 0;

=================================fputc()写文件=========================================
//fputc()写文件, 一次只能写入一个字符
fputc('h', fp);
fputc('e', fp);
fputc('l', fp);
fputc('l', fp);
fputc('o', fp);
//写入到屏幕的话将fp改成stdout即可
//写入26个字母
char ch = 'a';
while(ch <= 'z'){
    fputc(ch, fp);
    ch++;
}
//写入一个字符串
char buf[] = "abcdefghijklmn";
int i = 0;
int n = strlen(buf);
for(i=0; i<n; i++){
    fputc(buf[i], fp); //fputc(*(buf+i), fp);
}

=================================fgetc()读文件=========================================
char ch;
while(1)
{        
    ch = fgetc(fp);
    // 如果是文本文件,可以通过-1(EOF)判断文件是否结尾
    // 如果是二进制文件, 文件中会有很多的-1, 此时就不能通过-1判断文件是否结尾, feof()可判断任何文件结尾
    //if (ch == -1)
    //if (ch == EOF) // 系统的宏定义,即-1
    if(feof(fp)) // 如果到文件结尾返回真, 执行此文件之前必须读过了文件,因为函数会从读过的字符中判断,否则直接调用永远访问假
    {
        break;
    }
    printf("%d\n", ch);
}

=================================练习栗子 实现vi命令=========================================
//1.以写的方式打开文件, w, 路径为argv[1]
FILE *fp = fopen(argv[1], "w");

//从键盘读取内容fgets(), 键盘输入的关联指针是"stdin", 放入字符数组
//字符数组内容, 一个一个字符往文件里面写
char buf[1024];
while(1){
    // 默认遇到换行符, 便结束此次的读取工作, 换行符都放在buf中
    // 可以人为fgets()是按行读取的
    fgets(buf, sizeof(buf), stdin);
    if(strncmp(buf, ":wq", 3) == 0){
        break;
    }

    // 将读取到的内容写入文件
    int i = 0;
    while(buf[i] != '\0'){
        fputc(buf[i], fp);
        i++;
    }
}

//关闭文件
fclose(fp);


=================================fputs()=========================================
// 用法: 将字符串放到文件关联指针所关联的文件中去(可以是磁盘文件, 也可以是设备文件, 如屏幕)
char buf[] = "hello\n";
// 把buf的内容写到stdout所代表的文件中, 即显示屏幕
fputs(buf, stdout);

// fputs()写入文件, 只需要一个FILE *类型的指针即可
FILE *fp = fopen("tt11.txt", "w");
fputs("hello world\n", fp);
char *p = "bombomxiakalaka\n";
fputs(p, fp);


=================================fgets()=========================================
FILE *fp = fopen("tt11.txt", "r");
// 读文件
char buf[100];

// 1.从fp所关联的文件读取内容, 放到buf, 一次最大读取为(sizeof(buf) - 1), 因为要留一个放'\0'
// 2.遇到换行符, 文件结尾, 出错, 结束本次读取
fgets(buf, sizeof(buf), fp);
printf("buf=%s\n", buf);


=================================fprintf()=========================================
1.以格式化的方式将字符数组(参数2)放到文件中(参数1:FILE *)
FILE *fp = fopen("tt11.txt", "w+");

// 写文件fprintf()
int i = 0;
int n = 10;
int num = 0;
// 设置随机种子
srand((unsigned int)time(NULL));
for(i=0; i<n; i++){
    num = rand()%100;
    fprintf(fp, "%d\n", num);
}

=================================fscanf()=========================================
1.格式化的方式从文件中读取字节放到内存中
FILE *fp = fopen("tt11.txt", "r+");
int num;
fscanf(fp, "%d\n", &num);

=================================fwrite()=========================================
FILE *fp = fopen("tt11.txt", "w");

Student s1 = {18, "mike", 59};
// 参数1: &s1, 需要往文件写内容的变量首地址
// 参数2: sizeof(Student), 往文件写入内容的块大小
// 参数3: 1, 往文件写入内容的块数目
// ret: 返回值为写入成功时写入内容的块数目
int ret = fwrite(&s1, sizeof(Student), 1, fp);

=================================fread()=========================================
struct Student s[10];
// 参数1: 用于存储将要从文件读取的数据的内存空间的首元素地址
fread(s, 1, sizeof(struct Student)*4, fp);
for (int i = 0; i < 4; i++)
{
    printf("%d, %s, %d\n", s[i].age, s[i].name, s[i].score);
} 


=================================拷贝文件(cp命令)=========================================
// windows下默认把对象文件当做文本文件, 文本文件遇到特殊字符就会中断, 所以windows下打开文件的模式需要使用"rb", "wb",
// 加上"b"的话windows和Linux平台都将兼容
FILE * fp = fopen(argv[1], "rb"); // windows下使用"rb", Linux下使用"r"和"rb"等价
FILE * w_fp = fopen(argv[2], "wb"); // windows下使用"wb", Linux下使用"w"和"wb"等价
char buf[4*1024]; // 一次读取4k
int len;    
while (1)
{
    len = fread(buf, 1, sizeof(buf), fp);
    printf("len = %d\n", len);
    if (len == 0)
    {
        break;
    }
    fwrite(buf, 1, len, w_fp);
}
fclose(fp);
fclose(w_fp);


=================================随机位置的读写=========================================
long ftell(FILE *stream) 获取文件流(文件光标)的读写位置, 将光标放到文件末尾,在查看光标位置(即文件大小/字节)
void rewind(FILE *stream) 重置读写位置(光标)

int fseek(FILE *stream, long offset, int whence)
    whence有三个值:
        SEEK_SET: 从文件开头移动offset个字节
        SEEK_CUR: 从当前位置移动offset个字节
        SEEK_END: 从文件末尾移动offset个字节
fseek(fp, 0, SEEK_SET); 将光标移到 在开头便宜0个字节的位置, 回到开头的作用
fseek(fp, 100, SEEK_SET); 在开头向右便宜100个字节
fseek(fp, 100, SEEK_CUR); 在当前位置向右便宜100个字节
fseek(fp, 0, SEEK_END); 将光标移到 在结尾位置偏移0个字节(的位置), 即将光标移到文件末尾


目标文件中有三个struct Student类型的实例, 读取第三个struct Student类型的实例
struct Student s;
fseek(fp, sizeof(s)*2, SEEK_SET);
int ret = fread(&s, 1, sizeof(s), fp);
printf("ret=%d\n", ret);
printf("%d, %s, %d\n", s.age, s.name, s.score);


=================================文件的重命名和删除=========================================
int remove(const char *pathname) 返回值:成功0 失败-1
int rename(const char *oldpath, const char * newpath) 返回值:成功0 失败-1

=================================文件缓冲区=========================================
1. 默认情况下, 写入文件的数据, 其实是先写入到缓冲区, 缓冲区满了, 自动刷新缓冲区(数据写入文件)
2. 文件正常关闭, 缓冲区的数据也会写入文件
3. 缓冲区没有满的时候, 文件不关闭, 程序没有结束, 要实现实时刷新, 调用fflush
4. 程序正常关闭, 缓冲区的数据也会写入文件


=================================vs2010调试错误=========================================
错误	1	error LNK1123: 转换到 COFF 期间失败: 文件无效或损坏...
C:\Program Files\Microsoft Visual Studio 10.0\VC\bin



=================================选择排序=========================================
/*选择排序*/
int choose_sort(int *int_array, int n)
{
    int a[] = {2, 10, 8, 7, 5, 4, 1, 3, 6, 9};  
    int temp = 0;
    // printf("排序前:");
    // for (int i = 0; i < n; i++)
    // {
    //     printf("%d ", a[i]);
    // }
    // printf("\n");

    for (int i = 0; i < n - 1; i++)
    {
        for (int j = i+1; j < n; j++)
        {
            if (a[i] > a[j])
            {                
                temp = a[i];
                a[i] = a[j];
                a[j] = temp;
            }            
        }        
    }
    // printf("排序后:");
    for(int i = 0; i < n; i++){
        printf("%d ", a[i]);
    }
    printf("\n");
    return 1;
}

需要的地方调用:
    int a[] = {2, 10, 8, 7, 5, 4, 1, 3, 6, 9};
    int n = sizeof(a)/sizeof(a[0]);
    // 这里的实参a是数组类型, choose_sort()的第一个参数(形参)是指针类型, 参数传递过程实际上是
    // 数组(a)复制了一份赋值给a, 而不是把地址传递过去了
    choose_sort(a, n);


=================================数据类型的本质=========================================
类型(int, char...): 固定内存大小的别名(4个字节大小的内存空间叫做整型)
编译器可以根据类型 预算对象(变量)分配的内存空间大小
int a[10]; // 告诉编译器开辟一个4*10大小的内存空间
a: 数组名/数组首元素地址(首元素是int类型)/数组首地址, 一个元素4个字节, +1即size加4
&a: 整个数组的首地址一个数组4*10=40个字节, 所以+1即size加40


=================================份文件/多文件=========================================
1) 分文件时, 防止头文件重复包含
#pragma once

2) 让c代码可以在c++编译器编译运行
// __cplusplus是编译器提供好的宏, 不是自定义的
#ifdef __cplusplus
extern "C"{
#endif // __cplusplus

// 函数的声明

#ifdef __cplusplus
}
#endif // __cplusplus

=================================指针做参数输入输出特性=========================================
void fun(char **p /* in */){}
void fun2(char **p /* out */, int *len){
    if(p == NULL){
        return;
    }
    char *tmp = (char *)malloc(100);
    if(tmp == NULL){
        return;
    }
    strcpy(tmp, "abcd");

    // 间接赋值
    *p = tmp;
    *len = strlen(tmp);
}
int main(void){
    // 输入, 主调函数分配内存
    char buf[100] = {0};    
    fun(buf);

    // 输出, 被调用函数分配内存, 地址传递
    char *p = NULL;
    int len = 0;
    fun2(&p, &len);
}

=================================字符串包含/字符串是否包含/子字符串substr=========================================
利用strstr()标准库函数找出一个字符串中substr出现的个数
int str_contains(char * src, char * substr, int * count){
    while (src = strstr(src, substr))
    {
        (*count)++;
        src = src + strlen(substr);      
        if (*src == 0)
        {
            break;
        }        
    }
    return 0;
}
int main(void){
    char *p = "11abcd111122abcduuw98982abcd983387wfabcdqqq";
    char *substr = "abcd";    
    int count = 0;
    str_contains(p, substr, &n);
    printf("子字符串出现次数 = %d\n", count);
}


======================去除字符串首尾空格/去除字符串空格/两头堵模型/是否空格isspace()==========================
// 去处字符串inbuf首尾的空格, 去除空格后的字符串为outbuf, 成功返回0
int trim_space(char *inbuf, char *outbuf)
{
    if (inbuf == NULL || outbuf == NULL)
    {
        return -1;
    }
    
    char *p = inbuf;
    int begin = 0;
    int end = strlen(p) - 1;
    int n = 0; // 非空元素个数
    if (end < 0)
    {
        return -2;
    }
    //从左往右移动, 如果当前字符为空, 而且没有结束
    while (p[begin] == ' ' && p[begin] != 0)
    {
        begin++; //指针位置向右边移动一位
    }
    //从右往左移动, 如果当前字符为空
    while (p[end] == ' ')
    {
        end--; // 往左移动
    }
    n = end - begin + 1; // 非空元素个数        
    strncpy(outbuf, p + begin, n);
    outbuf[n] = 0;
    return 0;
}

int main(){
    char p1[] = "  hello   ";    
    char p1_out[50] = {0};    
    trim_space(p1, p1_out);
}


============================键值对字符串根据键获取值/可应用于配置文件===========================
// 根据键值对字符串("key1 =  value1")的键, 获取值(去空格)
int get_value_by_key(char *key_value_buf, char *key_buf, char *value_buf, int *value_buf_len)
{
    /*
    key_value_buf = "key1 =     value1";
    key_buf = "key1";        
    */
   if (key_buf == NULL || key_value_buf == NULL || value_buf == NULL || value_buf_len == NULL)
   {
       return -1;
   }
   char *p = NULL;
   // 查找匹配键值, "key1 =     value1"找"key1"
   p = strstr(key_value_buf, key_buf);
   if (p == NULL)
   {
       return -2;
   }
   // 找到key_buf, 重新设置起点, 跳过"key1", 即"key1 =     value1" => " =     value1";
   p = p + strlen(key_buf);
   // 查找"="
   p = strstr(p, "=");
   if (p == NULL)
   {
       return -3;
   }
   // 找到"="
   // p = p + 1;
   p++;
   int ret = trim_space(p, value_buf);
   if (ret != 0)
   {
       printf("trim_space error: %d\n", ret);
       return ret;
   }
   // 获取长度
   *value_buf_len = strlen(value_buf);
   return 0;
}


=================================const的使用===================================
从左往右看, 跳过类型, 看修饰谁
如果是*, 说明指针指向的内存不能改变
如果是指针变量, 说明指针的指向不能改变, 指针的值不能修改

MyStruct const *p;  // 指向内存的值不能变, 指针的值(指向的内存)可以改变
MyStruct * const p; // p的值(指向的内存)不能改变, 指向的内存的值可以改变

=================================二级指针和一级指针用于函数传参时的区别===================================

二级指针目的: 子函数中操作main()函数的void *类型的变量(主要是改变指针的值, 即指向内存)
若是需要改变指针内存的值, 一级指针即可


一级指针(跟值传递差不多), 参数传递过程为p2 = p1, p2的操作不影响p1
p1       main()函数中的指针p
-----
p2       子函数中的形参p

二级指针 p2指向p1, 通过p2可以操作p1(通过子函数操作main函数中的p1)
p1<-----      main()函数中的指针p void *
-----  |
p2----->       子函数中的形参p void **


=================================二维数组===================================
char b[30];
&b -> &b + 1    (首行地址)相差30
b -> b + 1      (首地址)相差1











爱,死亡和机器人
自修室
曼达洛人
致命女人
切尔诺贝利









