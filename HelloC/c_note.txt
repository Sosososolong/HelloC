=========================================================================
1.p[i]和*(p+i)相同
const修饰的结构体指针变量: 变量能修改, 但是指针指向的内存不能修改

2.windows平台的文本换行符"\r\n"
====hello world====
111
222
333

Linux平台的文本换行符"\n"
在windows平台下以文本方式打开文件: 读取文件, 会将"\r\n"换成"\n", 写入文件的时候, 会将"\n"换成"\r\n"
如果以二进制方式打开文件, 那么就不会有上面的转换过程

3.数组在函数间的传递, 注意实参类型(数组), 形参类型(指针)
int a[] = {2, 10, 8, 7, 5, 4, 1, 3, 6, 9};
int n = sizeof(a)/sizeof(a[0]);
// 这里的实参a是数组类型, choose_sort()的第一个参数(形参)是指针类型, 参数传递过程实际上是
// 数组(a)复制了一份赋值给a, 而不是把地址传递过去了
choose_sort(a, n);

4.4个字节大小的内存空间叫做整型

5.字符'\0'和数字0是等价的

6.char str[] = "abc"; // str是首地址,常量,不能作为指针使用,"abc"在文字常量区拷贝一份到栈区
  char *str = "abc"; // str是指针, 直接指向文字常量区的"abc"

7.栈的生长方向,递减,从高地址往低地址分配,首地址在低位(指针进行加法运算得到首地址后面的内存), 后进先出, 堆相反

fgets() 
1.从文件中(参数3:文件指针,文件可以是设备文件or磁盘文件) 读取一定长度的字节(参数2: int) 存放到内存的字节数组中(参数1: char *)
2.当参数3是stdin的时候(关联键盘的设备文件), 直到键盘输入回车, 从而从键盘读取输入的一行内容

fputs()
1.将一个字符串(参数1: char *)写入到一个文件指针(参数2: FILE */stdout)所关联的文件中(磁盘文件or设备文件)

sscanf()
1.有点类似于拆包,将一个字符串中的字符按类型以一定的格式提取出来赋值给新的变量(从字符串中获取字节)
char buf[100] = "1+2=\n";
int a, b;
char ch;
sscanf(buf, "%d%c%d=\n", &a, &b, &ch);

fprintf()
1.以格式化的方式将字符数组(参数2)放到文件中(FILE *)



a=0;
a++ && aa++;
a=?

========================================================================

===================================指针=====================================
只有使用“&数组名”时，才是取数组首地址；直接打印数组名或者&数组名[0]都是取得数组首元素地址
"&数组首元素变量名"结果是变量的地址(此变量占据的是数组之外的另外一块内存空间)

char *tmp;
char **p = &tmp;  //ok

//str首元素 是什么类型？ char *
//&str[0], 代表首元素地址，str等价于&str[0](数组名字就是数组首元素地址)
char *str[] = {"abc", "micke", "hello"}; //数组每一项都是char *类型（"abc"就是"abc"首元素地址）
char **p = str;  //char **指向char *
char **p = &str[0]

//下面三者等级， 编译器都当做char **p处理， 形参中的数组都是指针(数组名为元素首地址)，不是数组
void fun(char **p);
void fun(char *p[]);
void fun(char *p[100]);

void fun(int a[]);
void fun(int a[100]);
void fun(int *a)

//p2是数组
char *p2[] = {"abc", "mike", "hello"}
//p2是指针
char * * p2;

===================================静态的局部变量=====================================
存储在"data区"(函数中的局部静态变量在函数调用前就分配空间了,程序结束前不会释放)
初始化语句(static int a = 0;)只会执行一次,但是可以赋值多次    ****
只能用常量初始化(不要用变量给它赋值,因为变量只有程序执行到才会给变量分配空间,而它一开始就分配了空间) ****
在编译阶段就已经分配内存空间,函数没有调用前它就已经存在
如果没有被初始化,默认值为0(普通局部变量是随机数)

===================================普通全局变量=====================================
在定义之前若要使用可以声明(extern int a;) 可以声明多次, extern为声明的关键字
    extern int b = 10; //err,只有声明,没有定义,无法给变量赋值
在编译阶段已经分配空间(函数没有执行前),只有在整个程序结束才自动释放

缺陷:
    如果定义一个全局变量,没有赋值(初始化),无法确定是定义还是声明
    如果定义一个全局变量,同时初始化,这个肯定是定义

=================================声明一个全局变量=====================================
定义在函数外面,其他文件也都能用,一个全局变量多个文件中只能定义一次
如果要使用另一个.c文件中定义的全局变量, 需要声明一下,虽然可以不用extern,带上extern比较清晰
extern int a;
这种方式可行,但是使用头文件的方式(声明所有的变量和函数)更加优秀

=================================声明一个函数=========================================
//假设想要调用另一个.c文件中的一个test()函数,需要声明,声明的时候有没有extern无所谓
extern void test(); 或者 void test();
这种方式可行,但是使用头文件的方式(声明所有的变量和函数)更加优秀

=================================全局静态变量=========================================
跟普通的全局变量相比,作用域不一样(文件作用域)
extern关键字只适用于普通全局变量

一个文件有且只有一个static全局变量的定义
static全局变量只能在当前文件中使用

=================================内存分区/内存四区=========================================
gcc编译器:
    1.预处理,头文件展开,宏定义展开,条件编译,去掉注释
    2.编译,生成汇编代码
    3.生成目标代码.o
    4.关联链接,生成可执行程序
生成a.out文件, 终端:size a.out
    text    data    bss     dec     hex     filename
    1099    544     8       1651    673     a.out

a.说明编译生成可执行程序后,程序执行前,就已经"确定"(并没有加载到内存)了这几个 内存分区,虽然分区确定了,但是没有加载内存
程序只有运行时才会加载内存:
    text(代码区): 只读,函数
    data: 初始化的数据,全局变量和静态变量, 文字常量区(只读)
    bss: 没有初始化的数据,全局变量和静态变量
b.当运行程序,加载内存,首先根据前面确定的内存分区(text,data,bss)先加载, 然后额外加载两个区
    text(代码区): 只读,函数
    data: 初始化的数据,全局变量和静态变量, 文字常量区(只读)
    bss: 没有初始化的数据,全局变量和静态变量
    stack(栈区): 普通局部变量
    heap(堆区): 手动申请空间,手动释放, 整个程序结束,系统也会自动回收,如果没有手动释放,程序也没有结束
        这个堆区空间不会自动释放


堆区(heap): Malloc/new free/delete, 操作系统管理
栈区(stack): 程序局部变量
    char str[] = "abcd"; // 现在文字常量区放一个"abcd\0", 然后拷贝一份到栈区"abcd\0"
全局区(global): 常量和全局变量, 操作系统管理
    全局变量
    静态变量
    文字常量区
代码区(code): 操作系统管理



=================================打字游戏=========================================
1.生成随机字母('a'+0~25)

// 用随机字母填充字符数组, 字符数组的总长度(包含结束符)为宏定义MAX(51个)
// str 需要填充的字符数组的首地址 
void fill_char_array_with_rand_char(char *str)
{
    srand((unsigned int)time(NULL)); //随机种子
    int i = 0;
    for (i = 0; i < MAX - 1; i++)
    {
        // rand() % 26, 得到0~25的一个随机数
        *(str + i) = rand() % 26 + 'a';
    }

    *(str + MAX - 1) = '\0';
}


=================================结构体=========================================
struct Student
{
    char name[50];
    int age;
    int score;
};
类型名: struct Student; (别忘了struct)
变量名: struct Student stu;
//stu.name = "mike"; //error, 因为数组名是常量, 只读
strcpy(stu.name, "mike");
stu.age = 18;
stu.score = 60;

只有定义的时候才能初始化:
struct Student stu2 = {"mike", 18, 60};

如果是指针变量, 使用"->":
struct Student *p;
p = &stu2; //指针有合法指向, 才能操作结构体成员
strcpy(p->name, "mike");
p->age = 18;
p->score = 99;

任何结构体变量都可以用"."或者"->"操作成员
(&stu2)->age = 18; //求得变量的指针(地址)时用 "->"
(*p).age = 18; //通过指针前加"*", 直接操作结构体内存空间时用"."

相同类型的2个结构体变量可以相互赋值
struct Student s1 = {"mike", 18, 88};
struct Student S2;
s2 = s1; //值传递, 两个变量是没有关系的独立内存

指针指向堆区空间
struct Student *p;
p = (struct Student *)malloc(sizeof(struct Student));
if(p == NULL){
    printf("malloc error\n");
    return 0;
}   
...
if(p != NULL){
    free(p);
    p = NULL;
}


成员指向data区或者栈区或者栈区
struct Student{
    int age;
    char *name;
    int score;
};
int main(){
    struct Student s;
    s.age = 19;
    s.name = "mike"; // 指针变量保存字符串常量的首地址, 相当于char *p = "mike"; "mike"在文字常量区
    // char buf[100];
    // s.name = buf; //指向栈区空间
    // strcpy(s.name, "mike");

    // s.name = (char *)malloc((strlen("mike") + 1) * sizeof(char));  // 指向堆空间
    // strcpy(s.name, "mike");
    
}


=================================共用体(联合体)=========================================
union Test{
    unsigned char a;
    unsigned short b;
    unsigned int c;
    double d;
};

int main(){
    // 1.共用体的大小为最大成员的大小
    printf("%lu\n", sizeof(union Test)); // 8(double的长度)
    // 2.共用体公用一块内存, 所有成员的地址一样(首地址相同)
    union Test obj;
    printf("%p, %p, %p, %p\n", &obj, &ojb.a, &obj.b, &obj.c, &obj.d); //打印出的所有地址都相同
    
    // 3.给某个成员赋值, 会影响到另外的成员
    // 左边是高位, 右边是低位
    // 高位放高地址, 低位放低地址(小端)
    obj.c = 0x44332211; (16进制可以为每个字节赋值, 每两个16进制占一个字节, 因为一个字节8位,二进制最大能存储255个值,而两位的16进制最大数也是255)
    printf("obj.c = %x\n", obj.c); // 44332211 
    printf("obj.a = %x\n", obj.a); // 11
    printf("obj.b = %x\n", obj.b); // 2211

    obj.a = 0xaa;
    printf("obj.c = %x\n", obj.c); // 443322aa
    printf("obj.a = %x\n", obj.a); // aa
    printf("obj.b = %x\n", obj.b); // 22aa


}


=================================枚举 enum=========================================
主要作用是替代如下定义宏的方式:
#define MAX 51  // 定义宏
#define pink 0
#define red 1
#define green 2
#define white 3
#define yellow 4

枚举的方式:
// 里面的成员是一个标识符, 枚举常量
// 第一个成员如果没有赋值, 默认为0, 下一个成员比上一个多1
enum Color
{
    pink, red, green, white, yellow
};


=================================文件 概述=========================================
printf(); // 把内存中的值显示(写)到屏幕  
过程:
内存->缓冲区(存满一次提交)->屏幕(文件?)

scanf(); 
键盘(文件?)->缓冲区->内存变量

FILE 所有平台名字都一样, FILE是一个机构提类型, 里面的成员功能一样,不同平台成员的名字不一样.
FILE *fp
1. fp指针, 只调用了fopen(), 在堆区分配空间, 把地址返回给fp
2. fp指针不是指向文件, fp指针和文件关联, fp内部成员保存了文件的状态
typedef struct
{
    short level; //缓冲区"满"后者"空"的程度
    unsigned flags; //文件状态标识
    char fd; //文件描述符(其实就是一个整型)
    unsigned char hold; //如无缓冲区不读取字符
    short bsize; //缓冲区的大小
    unsigned char *buffer; //数据缓冲区的位置
    unsigned ar; //指针, 当前的指向
    unsigned istemp; //临时文件指示器
    short token; //用于有效性的检查
}

3. 不能直接对fp指针进行操作, 必须通过文件库函数来操作fp指针

4. 通过库函数操作fp指针, 对文件的任何操作, fp里面成员会相应的变化(系统自动完成)


=================================文件 分类(磁盘文件和设备文件)=========================================
磁盘文件
指一组相关数据的有序集合, 通常存储在外部介质(如磁盘)上, 使用时才调入内存
设备文件
在操作系统中, 把每一个与主机相连的输入/输出设备看做是一个文件, 把它们的输入输出等同于对磁盘文件的读和写


=================================文件 操作流程=========================================
1. 打开文件fopen()
2. 读写文件
    1) 按字符读写fgetc(), fputc()
    2) 按字符串(行)读写文件fgets(), fputs()
    3) 文件结尾判断 feof()
3. 关闭文件


读写文件, 需要fp指针(FILE *)结合相关库函数使用才行, fp指针指向的内存空间记录了目标文件的相关信息, printf()函数其实是针对屏幕的, 而屏幕也可以看做一个文件,
与屏幕也有个相关的"fp指针"(FILE *), 叫做"stdout", 将"stdout"关联到一个磁盘文件, 那么即可对磁盘文件进行操作

理解性代码(不用于执行)
printf("before aaaaa\n");  //内存中已经加载了文件相关信息的"stdout"指针, 通过"stdout"向屏幕写入字符串
fclose(stdout); //切断了"stdout"指针(FILE *)指向
stdout = fopen("./01.txt", "w"); //fopen()打开一个文件, 并返回"FILE *"类型的指针赋值给"stdout"
if(stdout == NULL)
{
    // 打开文件失败
    printf("fopen error!");
    return -1;
}
// "stdout"指针指向的内存区域已经关联到了"01.txt"文件, 所以此代码的意图是写入字符串到"01.txt"文件中
// 然而这里只是帮助我们理解磁盘文件和设备文件的区别的代码, 并不能执行成功!!!!
// 实际思路一样的, 但是更改指针指向和打开文件的库函数有所不同
printf("after bbbbbb\n"); 

系统编程的代码思路:
printf("before aaaaaa\n"); // printf()函数的作用是往"1"代表的设备(标准输出设备)中写内容
close(1);  // "1"是文件描述符 本来代表标准输出设备(屏幕), 关闭"1"就切断了"1" 和 "屏幕"的关联, "1" 处于空闲状态
int fd = open("01.txt", O_WRONLY, 0777); //打开文件, 并返回一个最小可用的 "数字"(即"1"), "数字fd"代表"目标文件"
printf("after bbbbbb\n"); // 此时"1"代表"01.txt"文件,而printf()会往"1"中写入字符串,所以字符串被写入"01.txt"文件中





=================================文件 打开和关闭=========================================
FILE * fopen(const char *filename, const char * mode)

此函数在堆空间开辟一块内存空间, 存储了FILE结构体, FILE结构体中的成员记录了目标文件的状态, 最后函数返回FILE结构体的
内存地址, 即FILE *类型的fp

代码:
FILE *fp = NULL;
// "w", 如果文件不存在, 新建, 如果文件存在,清空再打开
// "r", 如果文件不存在, 打开失败
// "w+", 读写模式, 清空文件再打开
// "a", 如果文件不存在, 新建, 如果文件存在,不清空内容,光标自动放在文件末尾
fp = fopen("./02.txt", "r");
if(fp == NULL){
    perror("fopen");
    return 0;
}


fclose(fp);
fp = NULL;
return 0;

=================================fputc()写文件=========================================
//fputc()写文件, 一次只能写入一个字符
fputc('h', fp);
fputc('e', fp);
fputc('l', fp);
fputc('l', fp);
fputc('o', fp);
//写入到屏幕的话将fp改成stdout即可
//写入26个字母
char ch = 'a';
while(ch <= 'z'){
    fputc(ch, fp);
    ch++;
}
//写入一个字符串
char buf[] = "abcdefghijklmn";
int i = 0;
int n = strlen(buf);
for(i=0; i<n; i++){
    fputc(buf[i], fp); //fputc(*(buf+i), fp);
}

=================================fgetc()读文件=========================================
char ch;
while(1)
{        
    ch = fgetc(fp);
    // 如果是文本文件,可以通过-1(EOF)判断文件是否结尾
    // 如果是二进制文件, 文件中会有很多的-1, 此时就不能通过-1判断文件是否结尾, feof()可判断任何文件结尾
    //if (ch == -1)
    //if (ch == EOF) // 系统的宏定义,即-1
    if(feof(fp)) // 如果到文件结尾返回真, 执行此文件之前必须读过了文件,因为函数会从读过的字符中判断,否则直接调用永远访问假
    {
        break;
    }
    printf("%d\n", ch);
}

=================================练习栗子 实现vi命令=========================================
//1.以写的方式打开文件, w, 路径为argv[1]
FILE *fp = fopen(argv[1], "w");

//从键盘读取内容fgets(), 键盘输入的关联指针是"stdin", 放入字符数组
//字符数组内容, 一个一个字符往文件里面写
char buf[1024];
while(1){
    // 默认遇到换行符, 便结束此次的读取工作, 换行符都放在buf中
    // 可以人为fgets()是按行读取的
    fgets(buf, sizeof(buf), stdin);
    if(strncmp(buf, ":wq", 3) == 0){
        break;
    }

    // 将读取到的内容写入文件
    int i = 0;
    while(buf[i] != '\0'){
        fputc(buf[i], fp);
        i++;
    }
}

//关闭文件
fclose(fp);


=================================fputs()=========================================
// 用法: 将字符串放到文件关联指针所关联的文件中去(可以是磁盘文件, 也可以是设备文件, 如屏幕)
char buf[] = "hello\n";
// 把buf的内容写到stdout所代表的文件中, 即显示屏幕
fputs(buf, stdout);

// fputs()写入文件, 只需要一个FILE *类型的指针即可
FILE *fp = fopen("tt11.txt", "w");
fputs("hello world\n", fp);
char *p = "bombomxiakalaka\n";
fputs(p, fp);


=================================fgets()=========================================
FILE *fp = fopen("tt11.txt", "r");
// 读文件
char buf[100];

// 1.从fp所关联的文件读取内容, 放到buf, 一次最大读取为(sizeof(buf) - 1), 因为要留一个放'\0'
// 2.遇到换行符, 文件结尾, 出错, 结束本次读取
fgets(buf, sizeof(buf), fp);
printf("buf=%s\n", buf);


=================================fprintf()=========================================
1.以格式化的方式将字符数组(参数2)放到文件中(参数1:FILE *)
FILE *fp = fopen("tt11.txt", "w+");

// 写文件fprintf()
int i = 0;
int n = 10;
int num = 0;
// 设置随机种子
srand((unsigned int)time(NULL));
for(i=0; i<n; i++){
    num = rand()%100;
    fprintf(fp, "%d\n", num);
}

=================================fscanf()=========================================
1.格式化的方式从文件中读取字节放到内存中
FILE *fp = fopen("tt11.txt", "r+");
int num;
fscanf(fp, "%d\n", &num);

=================================fwrite()=========================================
FILE *fp = fopen("tt11.txt", "w");

Student s1 = {18, "mike", 59};
// 参数1: &s1, 需要往文件写内容的变量首地址
// 参数2: sizeof(Student), 往文件写入内容的块大小
// 参数3: 1, 往文件写入内容的块数目
// ret: 返回值为写入成功时写入内容的块数目
int ret = fwrite(&s1, sizeof(Student), 1, fp);

=================================fread()=========================================
struct Student s[10];
// 参数1: 用于存储将要从文件读取的数据的内存空间的首元素地址
fread(s, 1, sizeof(struct Student)*4, fp);
for (int i = 0; i < 4; i++)
{
    printf("%d, %s, %d\n", s[i].age, s[i].name, s[i].score);
} 


=================================拷贝文件(cp命令)=========================================
// windows下默认把对象文件当做文本文件, 文本文件遇到特殊字符就会中断, 所以windows下打开文件的模式需要使用"rb", "wb",
// 加上"b"的话windows和Linux平台都将兼容
FILE * fp = fopen(argv[1], "rb"); // windows下使用"rb", Linux下使用"r"和"rb"等价
FILE * w_fp = fopen(argv[2], "wb"); // windows下使用"wb", Linux下使用"w"和"wb"等价
char buf[4*1024]; // 一次读取4k
int len;    
while (1)
{
    len = fread(buf, 1, sizeof(buf), fp);
    printf("len = %d\n", len);
    if (len == 0)
    {
        break;
    }
    fwrite(buf, 1, len, w_fp);
}
fclose(fp);
fclose(w_fp);


=================================随机位置的读写=========================================
long ftell(FILE *stream) 获取文件流(文件光标)的读写位置, 将光标放到文件末尾,在查看光标位置(即文件大小/字节)
void rewind(FILE *stream) 重置读写位置(光标)

int fseek(FILE *stream, long offset, int whence)
    whence有三个值:
        SEEK_SET: 从文件开头移动offset个字节
        SEEK_CUR: 从当前位置移动offset个字节
        SEEK_END: 从文件末尾移动offset个字节
fseek(fp, 0, SEEK_SET); 将光标移到 在开头便宜0个字节的位置, 回到开头的作用
fseek(fp, 100, SEEK_SET); 在开头向右便宜100个字节
fseek(fp, 100, SEEK_CUR); 在当前位置向右便宜100个字节
fseek(fp, 0, SEEK_END); 将光标移到 在结尾位置偏移0个字节(的位置), 即将光标移到文件末尾


目标文件中有三个struct Student类型的实例, 读取第三个struct Student类型的实例
struct Student s;
fseek(fp, sizeof(s)*2, SEEK_SET);
int ret = fread(&s, 1, sizeof(s), fp);
printf("ret=%d\n", ret);
printf("%d, %s, %d\n", s.age, s.name, s.score);


=================================文件的重命名和删除=========================================
int remove(const char *pathname) 返回值:成功0 失败-1
int rename(const char *oldpath, const char * newpath) 返回值:成功0 失败-1

=================================文件缓冲区=========================================
1. 默认情况下, 写入文件的数据, 其实是先写入到缓冲区, 缓冲区满了, 自动刷新缓冲区(数据写入文件)
2. 文件正常关闭, 缓冲区的数据也会写入文件
3. 缓冲区没有满的时候, 文件不关闭, 程序没有结束, 要实现实时刷新, 调用fflush
4. 程序正常关闭, 缓冲区的数据也会写入文件


=================================vs2010调试错误=========================================
错误	1	error LNK1123: 转换到 COFF 期间失败: 文件无效或损坏...
C:\Program Files\Microsoft Visual Studio 10.0\VC\bin



=================================选择排序=========================================
/*选择排序*/
int choose_sort(int *int_array, int n)
{
    int a[] = {2, 10, 8, 7, 5, 4, 1, 3, 6, 9};  
    int temp = 0;
    // printf("排序前:");
    // for (int i = 0; i < n; i++)
    // {
    //     printf("%d ", a[i]);
    // }
    // printf("\n");

    for (int i = 0; i < n - 1; i++)
    {
        for (int j = i+1; j < n; j++)
        {
            if (a[i] > a[j])
            {                
                temp = a[i];
                a[i] = a[j];
                a[j] = temp;
            }            
        }        
    }
    // printf("排序后:");
    for(int i = 0; i < n; i++){
        printf("%d ", a[i]);
    }
    printf("\n");
    return 1;
}

需要的地方调用:
    int a[] = {2, 10, 8, 7, 5, 4, 1, 3, 6, 9};
    int n = sizeof(a)/sizeof(a[0]);
    // 这里的实参a是数组类型, choose_sort()的第一个参数(形参)是指针类型, 参数传递过程实际上是
    // 数组(a)复制了一份赋值给a, 而不是把地址传递过去了
    choose_sort(a, n);


=================================数据类型的本质=========================================
类型(int, char...): 固定内存大小的别名(4个字节大小的内存空间叫做整型)
编译器可以根据类型 预算对象(变量)分配的内存空间大小
int a[10]; // 告诉编译器开辟一个4*10大小的内存空间
a: 数组名/数组首元素地址(首元素是int类型)/数组首地址, 一个元素4个字节, +1即size加4
&a: 整个数组的首地址一个数组4*10=40个字节, 所以+1即size加40


=================================份文件/多文件=========================================
1) 分文件时, 防止头文件重复包含
#pragma once

2) 让c代码可以在c++编译器编译运行
// __cplusplus是编译器提供好的宏, 不是自定义的
#ifdef __cplusplus
extern "C"{
#endif // __cplusplus

// 函数的声明

#ifdef __cplusplus
}
#endif // __cplusplus

=================================指针做参数输入输出特性=========================================
void fun(char **p /* in */){}
void fun2(char **p /* out */, int *len){
    if(p == NULL){
        return;
    }
    char *tmp = (char *)malloc(100);
    if(tmp == NULL){
        return;
    }
    strcpy(tmp, "abcd");

    // 间接赋值
    *p = tmp;
    *len = strlen(tmp);
}
int main(void){
    // 输入, 主调函数分配内存
    char buf[100] = {0};    
    fun(buf);

    // 输出, 被调用函数分配内存, 地址传递
    char *p = NULL;
    int len = 0;
    fun2(&p, &len);
}

=================================字符串包含/字符串是否包含/子字符串substr=========================================
利用strstr()标准库函数找出一个字符串中substr出现的个数
int str_contains(char * src, char * substr, int * count){
    while (src = strstr(src, substr))
    {
        (*count)++;
        src = src + strlen(substr);      
        if (*src == 0)
        {
            break;
        }        
    }
    return 0;
}
int main(void){
    char *p = "11abcd111122abcduuw98982abcd983387wfabcdqqq";
    char *substr = "abcd";    
    int count = 0;
    str_contains(p, substr, &n);
    printf("子字符串出现次数 = %d\n", count);
}


======================去除字符串首尾空格/去除字符串空格/两头堵模型/是否空格isspace()==========================
// 去处字符串inbuf首尾的空格, 去除空格后的字符串为outbuf, 成功返回0
int trim_space(char *inbuf, char *outbuf)
{
    if (inbuf == NULL || outbuf == NULL)
    {
        return -1;
    }
    
    char *p = inbuf;
    int begin = 0;
    int end = strlen(p) - 1;
    int n = 0; // 非空元素个数
    if (end < 0)
    {
        return -2;
    }
    //从左往右移动, 如果当前字符为空, 而且没有结束
    while (p[begin] == ' ' && p[begin] != 0)
    {
        begin++; //指针位置向右边移动一位
    }
    //从右往左移动, 如果当前字符为空
    while (p[end] == ' ')
    {
        end--; // 往左移动
    }
    n = end - begin + 1; // 非空元素个数        
    strncpy(outbuf, p + begin, n);
    outbuf[n] = 0;
    return 0;
}

int main(){
    char p1[] = "  hello   ";    
    char p1_out[50] = {0};    
    trim_space(p1, p1_out);
}


============================键值对字符串根据键获取值/可应用于配置文件===========================
// 根据键值对字符串("key1 =  value1")的键, 获取值(去空格)
int get_value_by_key(char *key_value_buf, char *key_buf, char *value_buf, int *value_buf_len)
{
    /*
    key_value_buf = "key1 =     value1";
    key_buf = "key1";        
    */
   if (key_buf == NULL || key_value_buf == NULL || value_buf == NULL || value_buf_len == NULL)
   {
       return -1;
   }
   char *p = NULL;
   // 查找匹配键值, "key1 =     value1"找"key1"
   p = strstr(key_value_buf, key_buf);
   if (p == NULL)
   {
       return -2;
   }
   // 找到key_buf, 重新设置起点, 跳过"key1", 即"key1 =     value1" => " =     value1";
   p = p + strlen(key_buf);
   // 查找"="
   p = strstr(p, "=");
   if (p == NULL)
   {
       return -3;
   }
   // 找到"="
   // p = p + 1;
   p++;
   int ret = trim_space(p, value_buf);
   if (ret != 0)
   {
       printf("trim_space error: %d\n", ret);
       return ret;
   }
   // 获取长度
   *value_buf_len = strlen(value_buf);
   return 0;
}


=================================const的使用===================================
从左往右看, 跳过类型, 看修饰谁
如果是*, 说明指针指向的内存不能改变
如果是指针变量, 说明指针的指向不能改变, 指针的值不能修改

MyStruct const *p;  // 指向内存的值不能变, 指针的值(指向的内存)可以改变
MyStruct * const p; // p的值(指向的内存)不能改变, 指向的内存的值可以改变

=================================二级指针和一级指针用于函数传参时的区别===================================

二级指针目的: 子函数中操作main()函数的void *类型的变量(主要是改变指针的值, 即指向内存)
若是需要改变指针内存的值, 一级指针即可


一级指针(跟值传递差不多), 参数传递过程为p2 = p1, p2的操作不影响p1
p1       main()函数中的指针p
-----
p2       子函数中的形参p

二级指针 p2指向p1, 通过p2可以操作p1(通过子函数操作main函数中的p1)
p1<-----      main()函数中的指针p void *
-----  |
p2----->       子函数中的形参p void **


=================================二维数组===================================
char b[30];
&b -> &b + 1    (首行地址)相差30
b -> b + 1      (首地址)相差1


=================================字符串替换 replace_substr()===================================
// 在字符串(src)中找到匹配的子字符串(sub), 然后用另一个字符串(new_sub)替换子字符串(sub), (dst)为输出参数
int replace_substr(char* src, char** dst, char* sub, char* new_sub)
{
	if (src == NULL || dst == NULL || sub == NULL || new_sub == NULL)
	{
		return -1;
	}
	char* start = src;
	char* p = NULL;
	char tmp[512] = { 0 };
	int len = 0;
	do
	{
		p = strstr(start, sub);
		if (p != NULL)
		{
			len = 0;
			len = p - start;
			if (len > 0)
			{
				strncat(tmp, start, len);
			}
			strncat(tmp, new_sub, strlen(new_sub));
			// 重新设置起点位置
			start = p + strlen(sub);
		}
		else
		{
			strcat(tmp, start);
			break;
		}
	} while (*start != '\0');
	// 新字符串要传到主函数中, 所以此子函数调用结束不能释放, 需要在对空间开辟内存空间, 然后由主函数手动释放
	char* buf = (char*)malloc(strlen(tmp) + 1);
	strcpy(buf, tmp);

	// 间接赋值
	*dst = buf;
	return 0;
}

// 调用
int main(){
	char* p = "abcd23424abcd2222abcd888qqqqq";
	char* buf = NULL; // 在replace_substr函数中分配空间
	int ret = 0;
	ret = replace_substr(p, &buf, "abcd", "mmmnnn");
	if (ret != 0)
	{
		printf("replace_substr() error: %d\n", ret);
		return ret;
	}
	printf("p = %s\n", p);
	printf("buf = %s\n", buf);

	if (buf != NULL)
	{
		free(buf);
		buf = NULL;
	}
}


=================================字符串分割/分割字符串 split_string()===================================
// 用一个字符(c)分割字符串(str), 放到数组(buf)中, 并返回数组的长度(n)
int split_string(const char* str, char c, char buf[10][30], int* count)
{
	if (str == NULL || count == NULL)
	{
		return -1;
	}
	// str = "sfjlsf,sfa,abcd,3dedd,sss,aaa"
	const char* start = str;
	char* p = NULL;
	int i = 0;
	do
	{
		p = strchr(start, c);
		if (p != NULL)
		{
			int len = p - start;
			strncpy(buf[i], start, len);
			// 结束符
			buf[i][len] = 0;
			i++;
			// 重新设置起点位置
			start = p + 1;
		}
		else
		{
			strcpy(buf[i], start);
			i++;
			break;
		}
	} while (*start != 0);
	if (i == 0)
	{
		return -2;
	}
	*count = i;
	return 0;
}

// 调用
int main(){
	const char* p = "sfjlsf,sfa,abcd,3dedd,sss,aaa";
	char buf[10][30] = { 0 };
	int n = 0;
	int i = 0;
	int ret = 0;
	ret = split_string(p, ',', buf, &n);
	if (ret != 0)
	{
		printf("split_string() error: %d\n", ret);
		return ret;
	}
	for (i = 0; i < n; i++)
	{
		printf("%s\n", buf[i]);
	}
	printf("\n");
}


=================================数组指针===================================
1.先定义数组类型, 根据类型定义指针变量
typedef int A[10]; // A数组类型
A* p = NULL; // 数组指针类型变量
A a;
p = &a;

2.1 先定义数组指针类型, 根据类型定义变量
// 和指针数组写法 int* a[10]; 很类型  相比多了圆括号
typedef int(*P)[10];
P q; // 数组指针变量q
q = &a;

2.2 int(*q)[10]; // 没有typedef, q是数组指针变量
q = &a;


=================================二维数组数组名===================================
int a[][4] = { 1,2,3,4,5,6,7,8,9,10,11,12 };
a: 代表整个数组, 值是整个数组的首元素 {1,2,3,4} 地址
a+1: 值第二个元素(也是一个数组, 步长为4*4)地址, 等价于&a[1]  **************

*a: a是整个数组的首元素 "{1,2,3,4}" 的地址, *a为取整个地址的首元素 "{1,2,3,4}", 值为它的首元素 "1" 的地址
*(a+1): 整个数组地址加1, 取/代表第二个元素 "{5,6,7,8}", 值为 第二个元素 "{5,6,7,8}" 的首元素"5"的地址, 等价于a[1] ***********

*(a+1) + 1: (a+1)的值代表一级数组的第二个元素的地址,步长4*4, *(a+1)指向一级数组的第二个元素二级数组 "{5,6,7,8}",等价a[1], 值为"{5,6,7,8}"的首元素地址 "5" 的地址, 步长4
(a+1)和*(a+1)值相等, 代表的类型不同, 步长不同
再加1就得到"{5,6,7,8}"第二个元素"6"的地址, 所以*(a+1)+1 相当于 &a[1][1];


=================================二位数组作为形参===================================
1.数组作为形参都会退化为指针
2.重点在于指针的步长一致不一致

int a[][4] = { 1,2,3,4,5,6,7,8,9,10,11,12 }; //二位数组的形参步长取决于二级数组的长度(4)
void print_array(int (*p)[4])






=================================C++ 基础===================================
1. 常量const int a = 10, 在编译期间, 在常量表中添加键值对 "a" => 10, 当代码中遇到"a"的时候, 就会把10取出来, "a"不是存储在内存中开辟的一个变量, 它没有指针, 无法修改
2. 引用: 变量的别名
	int a = 10;
	// int & 使用引用类型数据, re就是a的别名
	// 引用一旦声明, 不可变更, re永远是a的别名
	// 声明的同时必须初始化, 声明之后使用re就相当与使用a
	int & re = a; 

	本质: 常量指针
	int & re = a; 编译器实际上进行的操作-> int* const re = &a;


=================================C++ 内联函数===================================
inline void printAB(int a, int b)
{
    cout << "a = " << a << ", b = " << b << endl;
}
(只有代码比较少的不包含for循环的简单的代码) 加inline使得函数称为inline函数, 由编译器处理, c++编译器直接将函数体插入在函数调用的地方(减少压栈出栈开销)
当函数体的执行开销 远远大于压栈, 跳转和返回所用的开销的时候, 内联将毫无意义



=================================C++ 函数指针===================================
int func(int a, int b){
	cout << "func" << endl;
}
1.定义一种函数类型
typedef int(MY_FUNC)(int, int);

MY_FUNC* fp = NULL;
fp = func;
fp(10,20); // 或者(*fp)(10,20); 

2.定义一个指向这种函数类型的指针类型
typedef int(*MY_FUNC_P)(int, int);

MY_FUNC_P fp2 = NULL;
fp2 = func;
fp2(10,20);

3.
int(*fp3)(int,int) = NULL;
fp3 = func;
fp3(10,20);

=================================C++ 构造函数的初始化列表===================================
class A{
public:
	A(int a){
		cout << "A()..." << endl;
	}
	~A(){
		cout << "~A()..." << endl;
	}
	void printA(){
		cout << "a = " << m_a <<endl;
	}
private:
	int m_a;
}

class B{
public:
	B(A &a1, A &a2, int b):m_a1(a1), m_a2(a2)
	{
		m_b = b;
	}

private:
	int m_b;
	A m_a1;
	A m_a2;
}


=================================C++ new&delete===================================
相对c语言中的malloc和free
new: 在堆区开辟一块空间(存类的对象), 并且调用类的构造函数
delete: 释放堆区的一块空间(类的对象所在内存空间), 并且调用对象的析构函数


=================================C++ 类的静态成员===================================
class A{
    static int a; // 不能在类里面初始化
}
int A::a = 10; // 在类的外面初始化静态成员变量


=================================C++ 友元函数===================================
当一个函数要频繁通过调用一个对象的get,set方法获取对象的某个私有属性, 就会出现频繁的压栈出栈开销, 怎么让这个外部函数直接使用对象的私有字段呢?
解:	在对象所在类的内部将 这个外部函数声明为 该类的友元函数:
	friend double PointDistance(Point& p1, Point& p2); // 声明后: 获取的p1的私有字段x -> p1.getX() 就可以直接写成 p1.x

还可以用同样的方式声明友元类


=================================C++ 操作符重载===================================
加号
Complex c3 = c1 + c2; // 相当于调用函数 Complex operator+(c1, c2);


=================================C++ 对象的方法调用底层实现===================================
=================================C++ const修饰的对象的引用调用成员方法的时候报错===================================
类{
	方法();
}
类 对象 = new 类;

对象.方法() => 实际上是调用：方法(&对象)
其中类中的方法的参数是一个 "类*" 类型, const修饰的对象的引用调用成员方法的时候, 实际传入的是一个 "const 类*" 类型

类{
	对象方法() const;
}
在方法声明和实现后面加上const, 那么“方法”的参数就是一个 “const 类*” 类型



=================================C++ 只能指针===================================
#include <memory>

{
	// 相当于 int* ptr = new int;
	auto_ptr<int> ptr(new int);
	*ptr = 20;
}


=================================C++ 继承/子类内存布局/子类父类的构造函数调用过程===================================
class Student2{
public:
	Student2 Student2(int id, string name, int score): Student(id, name){
		this->score = score;
	}
}
创建子类对象的时候, 先调用父类的构造函数创建一个父类对象A, 然后在调用子类自己的构造方法，完善子类的其他部分B。 "A+B"构成了整个子类对象


=================================C++ 多态/virtual虚方法===================================
现象: 一个基类型的对象A调用了一个方法m(), m()是一个虚方法，所有的子类都重写了方法m(), 对象A里面装的可能是基类的实例也可能是子类的实例, 是哪个类的实例就调用哪个类的方法m();
意义: 随着子类却可以不断的拓展 将这个基类型作为形参的方法可以一直使用

静态联编和动态联编: 程序没有运行的时候 编译器不知道父类指针指向的具体是父类对象还是子类对象 既然指针类型是父类的 编译器默认指针指向父类对象 所以默认会调用父类的成员方法(静态联编)
使用虚方法后就有了多态的现象 多态的发生是动态联编  是在程序执行时判断具体父类指针应该调用的方法


*虚析构函数(析构函数有时候也需要多态的支持): 当一个方法以一个基类(A* a)作为形参, 在函数中, delete a, 那么默认情况下也只会调用A类的析构函数, 如果传进来的实参是一个子类, 那么这个子类对象
在创建的过程中,先调用了父类的构造方法创建了一个父类的对象,在调用子类的构造方法完善了子类其余的部分初始化.
此是delete a的时候默认只会调用A的析构函数,只会释放子类对象中的A的构造函数创建的A对象,不会释放子类自身其余的部分,发生内存泄漏
解决思路就是让"delete a" 的时候发生多态, 方法跟上面一样, 在父类A的析构方法前面加上virtual关键字即可


=================================C++ 多态原理===================================
虚函数表和vptr指针
1.当类中声明虚函数时 编译器会在类中生成一个虚函数表
2.虚函数表是一个存储类成员函数指针的数据结构
3.虚函数表是由编译器自动生成和维护的
4.virtual成员函数会被编译器放入虚函数表中
5.存在虚函数时 每个对象中都有一个指向虚函数表的指针(vptr指针)


=================================C++ 纯虚函数===================================
类似于接口 类似C#中的抽象类 不能实例化
1.virtual double getArea() = 0;
2.如果一个类含有一个类似以上的抽象函数 那么这个类就是一个抽象类
3.抽象类的子类需要重写抽象类中的纯虚函数
4.抽象类作为抽象参数 依然可以实现多态



=================================C++进阶 函数模板===================================
将类型参数化(类似于泛型)

template<class T> // template<typename T>
void mySwap(T& a, T& b){
	T temp = a;
	a = b;
	b = temp;
}

原理: 编译阶段编译器会对模板函数进行两次编译, 第一次编译会正常编译模板函数, 第二次编译阶段根据模板函数调用时候传进去的参数类型, 在当前文件中会额外生成一个对应类型的普通函数
比如调用函数mySwap(1,2), 传进去的是两个整形, 匹配上模板函数, 那么会生成以下具体函数:
void mySwap(int& a, int& b){
	T temp = a;
	a = b;
	b = temp;
}


=================================C++进阶 类模板===================================
template<class T>
class Person{
public:
	Person(T id, T age){
		this->mid = id;
		this->mAge = age;
	}
private:
	T mid;
	T mAge;
}

使用时指定一个类型:
Person<int> p(10,20);


=================================C++进阶 类模板中的静态成员===================================
类模板中的静态成员(比如a)其实属于具体类的, 没有具体类, 静态成员没有意义, 不同的具体类中的静态成员a是不同的

template<class T>
class Person{
public:
	static int a;
}

// 静态成员类外初始化
template<class T> int Person<T>::a = 0;

Person<int> p1, p2, p3;
Person<int> pp1, pp2, pp3;
p1.a = 10;
pp1.a = 100; 
那么p1,p2,p3都是10, pp1, pp2, pp3都是100;


=================================C++进阶 对右值去引用??===================================
一个函数:
void PushBack(T& data){...}

调用函数:
int a = 1;
PushBack(a); //√
PushBack(1); //× 因为无法直接对右值取地址

重载函数void PushBack(T& data)
void PushBack(T&& data){...} // 实现完全一样



=================================C++进阶 类型转换===================================
static_cast			用于内置的数据类型的转换; 转换具有继承关系的对象指针或者引用, 子类型转父类型或者父类型转子类型都可以
	int a = 10;
	char c = static_cast<char>(a);

dynamic_cast		派生类(指针或引用)->基类(指针或引用), 转换前会进行对象类型检查

const_cast			主要对const的转换(增加或者去除变量的const特性给新的变量)

reinterpret_cast	用于没有任何关联之间的转换, 比如一个字符指针转换为一个整形数



=================================C++进阶 异常对象生命周期===================================
情况1: 调用拷贝构造
void func(){
	// 在抛出异常后, 此异常对象不会析构
	throw Exception();
}

void test(){
	try{
	}catch(Exception e){
		// 这里调用拷贝构造将上面func()函数抛出的异常拷贝一份给e, 此函数执行完毕(异常对象catch处理完之后), 上面的func()函数抛出的异常对象和e都会析构
	}
}


情况2: 捕获异常对象引用
void func(){
	// 在抛出异常后, 此异常对象不会析构
	throw Exception();
}

void test(){
	try{
	}catch(Exception& e){
		// 这里不会调用拷贝构造, e就是上面func()函数抛出异常的引用, 此函数执行完毕(异常对象catch处理完之后), 上面func()函数所抛出的异常对象析构
	}
}


情况3: 捕获异常对象指针
void func(){
	// 如果捕获此异常的指针, 那么下面这样构造对象就会在抛出异常后就析构, 那么下面test()中捕获的指针将会是一个野指针, 所以要在堆区开辟异常对象的空间, 手动控制异常对象的生命周期
	// throw Exception();

	throw new Exception();
}

void test(){
	try{
	}catch(Exception* e){
		// TODO: 异常处理

		// 最后手动释放上面func()函数抛出的异常对象
		delete e;
	}
}


=================================C++进阶 标准输出_格式化输出===================================
1.cout << "hello world!" << endl;

2.输出一个字符, 支持链式编程
cout.put('h').put('e').put('l') << endl;

3.写/输出一个字符串(二进制流的输出)
char str[] = "hello world!";
cout.write(str, strlen(str));

4.格式化输出
	4.1 成员方法的方式
	int number = 10;
	cout << number << endl; // 10
	cout.unsetf(ios::dec); // 卸载当前默认的十进制输出方式
	cout.setf(ios::oct); // 八进制输出
	cout.setf(ios::showbase); // 把八进制开头的0显示出来
	cout << number << endl; // 012

	4.2 通过控制符的方式(需要包含头文件: #include <iomanip>)
	int number2 = 10;
	// 0xa~~~~~~~
	cout << hex
		<< setiosflags(ios::showbase)
		<< setw(10)
		<< setfill('~')
		<< setiosflags(ios::left)
		<< number2
		<< endl;


=================================C++进阶 文件读写基本操作===================================
#include <fstream>
// 拷贝文件(包含文件读写的基本操作)
void copy_file() {
	char* file_name = "D:/others.project/clang/zerg/HelloC/HelloC/test_file_io.txt";
	char* target_file_name = "D:/others.project/clang/zerg/HelloC/HelloC/test_file_io_bak.txt";
	ifstream ism(file_name, ios::in); //只读方式打开文件
	ofstream osm(target_file_name, ios::out); //写方式打开文件
	// ofstream osm(target_file_name, ios::out | ios::app); // 追加的方式打开文件,没执行一次程序,都会追加内容
	if (!ism)
	{
		cout << "打开文件失败" << endl;
		return;
	}
	// 读文件
	char ch;
	while (ism.get(ch))
	{
		cout << ch;
		osm.put(ch); // 流写入一个字符
	}
	// 关闭文件
	ism.close();
	osm.close();
}


=================================C++进阶 二进制文件读写(可以将对象保存到文件再从文件读取出对象, 对象是以二进制存在于内存中的)===================================
class Person {
public:
	Person() {}
	Person(int age, int id) :age(age), id(id) {}
	void Show() {
		cout << "Age: " << this->age << " Id: " << this->id << endl;
	}
public:
	int age;
	int id;
};

// 二进制文件读写-对象序列化
void seri_obj_then_save_to_file() {
	// 文本模式读写就是会对换行操作符进行一个转换(windows平台), 在Linux平台文本模式读写和二进制模式读写没有区别
	Person p1(10, 20), p2(30, 40); // 二进制形式存储在内存中
	// 把p1, p2写进文件
	char* target_file_name = "D:/others.project/clang/zerg/HelloC/HelloC/test_file_io_bak.txt";
	ofstream osm(target_file_name, ios::out | ios::binary); // 二进制模式写
	osm.write((char*)&p1, sizeof(Person)); // 二进制方式写文件
	osm.write((char*)&p2, sizeof(Person)); 
	osm.close();
}
void read_binary_file() {
	char* target_file_name = "D:/others.project/clang/zerg/HelloC/HelloC/test_file_io_bak.txt";
	ifstream ism(target_file_name, ios::in | ios::binary);
	Person p1;
	Person p2;
	ism.read((char*)&p1, sizeof(Person)); // 从文件读取数据
	ism.read((char*)&p2, sizeof(Person));	
	p1.Show(); // Age: 10 Id: 20
	p2.Show(); // Age: 30 Id: 40
}


=================================C++进阶 基本概念: STL(Standard Template Library); 容器(container); 算法(algorithm); 迭代器(iterator)===================================
序列式容器: 容器中的元素是由 进入容器时机和地点决定的
关联式容器: 容器已经有规则, 进入容器的元素的位置按照规则找到对应的位置

迭代器: 可以这样理解: 用来遍历容器中元素的指针, 对指针的操作基本都能对迭代器操作. 实际上,迭代器是一个类, 这个类封装了一个指针

算法: 通过有限的步骤去解决问题


=================================C++进阶 STL容器迭代器的基本例子===================================
void test01() {
	vector<Person> v; // 定义一个容器
	Person p1(1, 2), p2(3, 4), p3(5, 6), p4(7, 8);
	v.push_back(p1);
	v.push_back(p2);
	v.push_back(p3);
	v.push_back(p4);

	// 通过STL提供的for_each算法
	// vector<int>::iterator 是迭代器的类型
	// vector<int>::iterator pBegin = v.begin();
	// vector<int>::iterator pEnd = v.end();
	// for_each(pBegin, pEnd, print_vector);
	for (vector<Person>::iterator it = v.begin(); it < v.end(); it++)
	{
		cout << "Age: " << it->age << ", Id: " << it->id << endl;
	}
}


=================================C++进阶 vector容器动态增长原理===================================
当插入新元素的时候, 如果空间不足, 那么vector会重新申请更大的一块内存空间, 将原空间的数据拷贝到新空间, 释放旧空间的数据, 再把新元素插入到新空间

=================================C++进阶 巧用swap缩小容器空间===================================
// v是一个已经存在的capacity值比较大的但是实际元素比较少的容器
// vector<int>(v), 首先通过拷贝构造初始化一个匿名对象, 这个匿名对象的capacity值就比较小, 再调用swap(v), 使得v指向这个匿名对象所在的空间, 匿名对象的指针指向了原来capacity值
// 比较大的内存空间, 并被释放, 此是v的capacity就变小了
vector<int>(v).swap(v);


=================================C++进阶 reserve预留空间===================================
// 如果你大致知道容易要存储元素的个数, 那么你可以用reserve预留空间
v.reserve(100000); // 预先留出足够的capacity(空间)


=================================C++进阶 deque容器===================================
1.相比vector容器, deque容器可以从头部push_front和pop_front元素

2.引入头文件#include <deque>

3.构造函数
deque<T> deqT; // 默认构造形式
	deque<int> d1;

deque(n, elem); // 构造函数将n个elem拷贝给本身
	deque<int> d2(10,5); // 用10个5初始化deque容器d2

deque(beg, end); // 构造函数将[beg, end)区间中的元素拷贝给本身
	deque<int> d3(d2.begin(), d2.end());

deque(const deque &deq); // 拷贝构造函数
	deque<int> d4(d3);

4.赋值操作
deque<int> d;
deque<int> d2;
deque<int> d3;
d.assign(10, 5); // 10个5放到容器中, 跟上面d2一样
d2.assign(d.begin(), d.end()); // 迭代器指定区间赋值
d3 = d2; // 等号赋值
d1.swap(d2); // 交换两个空间元素

5.deque大小操作
deque.size(); // 返回容器中元素个数
deque.empty(); // 判断容器是否为空
deque.resize(num); // 重新指定容器的长度为num, 若容器变长, 则以默认值填充新位置. 若容器变短,则末尾超出容器长度的元素被删除
deque.resize(num, elem); // 重新指定容器的长度为num, 若容器变长, 则以elem填充新位置, 若容器变短,则末尾超出容器长度的元素被删除

6.deque双端插入删除操作
push_back(elem);
push_front(elem);
pop_back();
pop_front();


=================================C++进阶 stack容器(U型模型) 先进后出===================================
#include <stack>
1.top() 返回栈顶元素
2.只能访问栈顶元素, 不提供迭代器, 不能遍历, 不支持随机存取
3.API
	stack<int> s1;
	stack<int> s2(s1);

	// stack操作
	s1.push(10);
	s1.push(20);
	s1.push(30);
	s1.pop(); // 删除栈顶元素(30)

	// 打印栈容器的数据
	while(!s1.empty()){
		cout << s1.pop() << " ";
		s1.pop();
	}


=================================C++进阶 queue容器(队列)===================================
#include <queue>
1.queue容器(队列容器): 先进先出(一端[队尾]插入, 另一端[队头]删除), 可访问队尾元素(back()),可访问队头元素(front()) 和栈容器一样不支持迭代器, 不支持随机访问, 不支持遍历
2.API
	queue<int> q; // 创建队列
	q.push(10);
	q.push(20);
	q.push(30);

	while(q.size()>0){
		cout << q.front() << " "; // 输出队头元素
		q.pop(); // 删除队头元素
	}


=================================C++进阶 list(链表)容器===================================
#include <list>
1.链表是由一系列的节点组成, 节点包含两个域, 一个数据域, 一个指针域.

2.链表内存分析
	2.1 非连续的. 添加删除元素 时间复杂度都是常数项,不需要移动元素, 比数组添加删除效率高
	2.2 链表在需要的时候才分配内存
	2.3 链表需要额外的空间保存节点关系

3.API
	list<int> mlist1;
	list<int> mlist2(10, 10); // 10个10初始化list容器
	list<int> mlist3(mlist2); // 拷贝构造
	list<int> mlist4(mlist2.begin(), mlist2.end());

	for(list<int>::iterator it = mlist4.begin(); it != mlist4.end(); it++){
		cout << *it << " ";
	}
	cout << endl;

	list<int> mlist;
	// 插入元素(头部)
	mlist.push_front(100);
	// 插入元素(尾部)
	mlist.push_back(200);

	// 插入元素
	// 在开始的地方插入300, 相当于push_front()
	mlist.insert(mlist.begin(), 300); 
	// 在尾部插入400, 相当于push_back()
	mlist.insert(mlist.end(), 400); 
	list<int>::iterator it = mlist.begin();
	it++;
	it++;
	// 第三个位置插入500
	mlist.insert(it, 500);

	// 删除
	mlist.pop_back();
	mlist.pop_front();
	mlist.erase(mlist.begin(), mlist.end()); // mlist.clear();
	// 删除匹配的所有元素(删除所有的200)
	mlist.remove(200);

	// 赋值
	list<int> mlist;
	mlist.assign(10, 10); // 往容器中放入10个10

	list<int> mlist2;
	mlist2 = mlist;

	mlist2.swap(mlist);

	// 存取
	front(); // 返回第一个元素
	back(); // 返回最后一个元素

	// 反转
	mlist.reverse(); 

	// 排序: list不支持随机访问, 所以算法库中的sort()方法不支持list的排序, list自己实现了排序的sort()方法, 如下
	mlist.sort(); // 默认从小到大


=================================C++进阶 set容器===================================
#include <set>
1. 基于红黑树, 不能有重复元素, 自动进行排序, 默认从小到大

2.
	set<int> s1;
	s1.insert(7);
	s1.insert(1);
	s1.insert(4);
	s1.insert(2);
	s1.insert(5);
	for(set<int>::iterator it = s1.begin(); it != s1.end(); it++){
		cout << *it << " ";
	}
	cout << endl; // 1 2 4 5 7

	// 赋值操作
	set<int> s2;
	s2 = s1;

	// 删除操作
	s1.erase(s1.begin()); // 根据迭代器删除
	s1.erase(7); // 删除元素7

	// 查找操作find()
	// 查找4是否存在, 存在则返回4的迭代器; 如果不存在, 返回map.end()
	set<int>::iterator ret = s1.find(4); 
	if(ret == s1.end()){
		cout << "没有找到" << endl;
	}else{
		cout << "ret: " << *ret << endl;
	}

	// 查找操作lower_bound(keyElem): 返回第一个key >= keyElem元素的迭代器
	s1.lower_bound(2); // 有2则返回2的迭代器, 没有则返回大于2的下一个元素的迭代器

	// 查找一个大于2的值, "1 2 4 5 7"的set<int>中将返回4
	s1.upper_bound(2); 

	// 返回lower_bound()和upper_bound()两个值
	pair<set<int>::iterator, set<int>::iterator> myret = s1.equal_range(2);
	if(myret.first == s1.end()){
		cout << "没有找到!" << endl;
	}else{
		cout << "找到lower_bound()的结果: " << *(myret.first) << endl;
	}
	if(myret.second == s1.end()){
		cout << "没有找到!" << endl;
	}else{
		cout << "找到upper_bound()的结果:" << *(myret.second) << endl;
	}

3. 仿函数指定set的排序规则
class mycompare {
public:
	bool operator()(int v1, int v2) const{
		return v1 > v2; // 降序
	}
};
void test01() {
	set<int, mycompare> s1;
	s1.insert(7);
	s1.insert(1);
	s1.insert(3);
	s1.insert(2);
	s1.insert(5);
	for (set<int>::iterator it = s1.begin(); it != s1.end(); it++)
	{
		cout << *it << " ";
	}
}

4. set容器保存对象, set容器是会排序的, 所以存入对象的时候, 需要指定排序的规则
class mycompare {
public:
	bool operator()(Person p1, Person p2) const{
		// 按年龄从大到小排序, ****那么find()查找的时候也只会根据对象的年龄进行查找, 而且插入容器的时候, 同样年龄的对象插入操作无效****
		return p1.age > p2.age;
	}
};

void test01() {
	set<Person, mycompare> s1;
	// Person(int age, int id);
	Person p1(10, 20), p2(30, 40), p3(50, 60), p4(40, 80);
	s1.insert(p1);
	s1.insert(p2);
	s1.insert(p3);
	s1.insert(p4);
	for (set<Person>::iterator it = s1.begin(); it != s1.end(); it++)
	{
		cout << "Age: " << it->age << " Id: " << it->id << endl;
	}
}


=================================C++进阶 pair对组===================================
// 构造方法创建实例
pair<int, int> pair1(10, 20);
cout << pair1.first << " " << pair1.second << endl;

pair<int, string> pair2 = make_pair(10, "aaa");
cout << pair2.first << " " << pair2.second << endl;

pair<int, string> pair3 = pair2;


=================================C++进阶 map/multimap容器===================================
#include <map>
1.相对于set, map具有键值对
2.map与multimap区别在于, map不允许相同key存在, multimap则允许相同key存在
3.使用:
	map<int,int> mymap;

	// 插入数据 pair.first为key值, pair.second为value值
	// 第一种
	pair<map<int,int>::iterator, bool> ret = mymap.insert(pair<int,int>(10,10));
	if(ret.second){
		cout << "第一次插入成功" << endl; // √
	}else{
		cout << "第一次插入失败" << endl;
	}
	ret = mymap.insert(pair<int,int>(10,20)); // 键相同插入会失败
	if(ret.second){
		cout << "第二次插入成功" << endl;
	}else{
		cout << "第二次插入失败" << endl; // √
	}

	// 第二种
	mymap.insert(make_pair(20,20));
	// 第三种
	mymap.insert(map<int,int>::value_type(30,30));
	// **第四种, key不存在则插入, key存在则是通过key修改value, 如果通过不存在的key去访问value, 那么会将key插入map,并给定一个随机的value值**
	mymap[40] = 40;

	// 通过迭代器打印
	for(map<int,int>::iterator it = mymap.begin(); it != mymap.end(); it++){
		// *it 取出来的是一个pair
		cout << "key: " << it->first << " value: " << it->second << endl;
	}

4.如果key是自定义类型, 需要跟set容器一样指定排序规则
// 自定义一个类型作为key的类型
class MyKey {
public:
	MyKey(int index, int id) {
		this->mIndex = index;
		this->mId = id;
	}
public:
	int mIndex;
	int mId;
};

class mykeycompare {
public:
	bool operator()(MyKey key1, MyKey key2)const {
		return key1.mIndex > key2.mIndex;
	}
};

void test01() {	
	map<MyKey, int, mykeycompare> mymap;
	mymap.insert(make_pair(MyKey(1,2), 10));
	mymap.insert(make_pair(MyKey(3,4), 20));
	for (map<MyKey, int>::iterator it = mymap.begin(); it != mymap.end(); it++) {
		cout << " mIndex: " << (it->first).mIndex << " mId: " << (it->first).mId << " second: " << (it->second) << endl;
	}
}

5. 通过一个元素a, 查找map中 >=a 的元素 和 >a 的元素
map<int,int> mymap;
mymap.insert(make_pair(1,2));
mymap.insert(make_pair(2,3));
mymap.insert(make_pair(3,4));
pair<map<int,int>::iterator, map<int,int>::iterator> ret = mymap.equal_range(2);
cout << "lower_bound()的结果: " << ret.first->first << " => " << ret.first->second << endl;
cout << "upper_bound()的结果: " << ret.second->first << " => " << ret.second->second << endl;


=================================C++进阶 容器总结===================================
1. 除了queue(队列)和stack之外, 每个容器都提供可返回迭代器的函数, 运用返回的迭代器就可以访问元素
2. 通常STL不会抛异常, 需要使用者传入正确的参数
3. 每个容器都提供了一个默认的构造的函数和默认的拷贝构造函数
4. 大小相关的构造方法: a: size()返回容器中元素的个数 b: empty()判断容器是否为空

vector:
	内存结构: 单端数组
	可随机存取: 是
	元素搜寻速度: 慢
	元素安插移除: 尾部
	场景: 比如历史操作记录的存储, 我们经常要查看历史记录, 比如上一次的记录, 上上次的记录, 但是却不会去删除记录

deque:
	内存结构: 双端数组
	可随机存取: 是
	元素搜寻速度: 慢
	元素安插移除: 头尾两端
	场景: 比如排队购票系统, 对排队者的存储可采用deque, 因为排队者需要经常进行头端的快速移除, 尾端的快速添加, vector如果要移除头端元素会移动大量数据, 速度慢

list:
	内存结构: 双向链表
	可随机存取: 否
	元素搜寻速度: 非常慢
	元素安插移除: 任意位置
	场景: 比如公交车乘客的存储, 随时有乘客下车, 支持频繁的不确定位置元素的插入和移除

set:
	内存结构: 二叉树
	可随机存取: 否
	元素搜寻速度: 快
	元素安插移除: /
	场景: 比如对手机游戏的个人得分记录的存储, 存储要求从高分到低分的顺序排列

multiset:
	内存结构: 二叉树
	可随机存取: 否
	元素搜寻速度: 快
	元素安插移除: /

map:
	内存结构: 二叉树
	可随机存取: 对key而言: 是
	元素搜寻速度: 对key而言: 快
	元素安插移除: /
	场景: 比如按ID号存储十万个用户, 想要快速通过ID号查找对应的用户. 二叉树的查找效率,这时就体现出来了. 如果是vector容器, 最坏的情况下可能要遍历完整个容器才能找到该用户

multimap:
	内存结构: 二叉树
	可随机存取: 否
	元素搜寻速度: 对key而言: 快
	元素安插移除: /


=================================C++进阶 函数对象(仿函数)===================================
1.概述: 重载函数调用操作符的类, 其对象称为函数对象(function object), 即他们是行为类似函数的对象, 也叫仿函数(functor), 其实就是重载"()"操作符, 使得类对象可以像函数那样调用

2.意义: 
	2.1 函数对象具有函数的功能, 同事它其实是一个对象, 可以将函数调用的一些状态存如对象的属性中
	2.2 举例: 上面2.1的特性在for_each()中运用
		MyPrint print;
		// 用一个新对象print2去接收函数的返回值, print2中存储了函数调用的时候需要存储的一些额外的信息
		#include <algorithm>
		MyPrint print2 = for_each(v.begin(), v.end(), print);

3.谓词
	是指普通函数或者重载的operator()返回值是bool类型的函数对象(仿函数). 如果operator接收一个参数,那么叫"一元谓词", 接收两个参数叫"二元谓词"

4.内置/内建的函数对象
	1.加法仿函数 template<class T> T plus<T>
	plus<int> myplus;
	myplus(10,20);
	2.减法仿函数 template<class T> T minute<T>
	3.乘法仿函数 template<class T> T multiplies<T>
	4.除法仿函数 template<class T> T devides<T>
	5.取模仿函数 template<class T> T modulus<T>
	6.减法仿函数 template<class T> T negate<T>
	...

5.******函数对象适配器*******
函数对象适配器是完成一些配接工作, 这些配接包括绑定(bind), 否定(negate), 以及对一般函数或者成员函数的修饰, 使其成为函数对象. 以下是一些函数对象适配器:

	场景描述: 如果某个地方只能调用一元函数对象, 但是我们的业务需求需要一个额外的参数, 我们需要使用二元函数对象, 那么就可以使用函数对象适配器(bind1st或者bind2nd)将我们的二元函数对象转换为一元	函数对象
	bind1st: 将参数绑定为函数对象的第一个参数

	bind2nd: 将参数绑定为函数对象的第二个参数(将一个二元函数对象转换为一元函数对象)
		#include <functional>
		// 如果要使用函数对象适配器, 需要继承 binary_function
		struct MyPrint : public binary_function<int, int, void>
		{
			void operator()(int v, int num) const {
				cout << v + num << " ";
			}
		};
		void test01() {	
			vector<int> v;
			for (int i = 0; i < 10; i++)
			{
				v.push_back(i);
			}
			
			// ****问题就是: for_each()的第三个参数需要的是一个一元函数对象, 如果我们使用的是一个二元函数对象就需要使用函数对象适配器将二元函数对象转换为一元函数对象****
			// for_each(v.begin(), v.end(), MyPrint()); // 传入仿函数, 元素为函数对象的参数, 即可打印所有元素
			// 若除了元素, 函数对象还需要传入另一个参数比如100, 需要使用函数对象适配器, bind2nd()将100绑定为函数对象的第二个参数即num, 若使用bind1st(), 则100将会成为第一个参数即v
			for_each(v.begin(), v.end(), bind2nd(MyPrint(), 100));
		}

	取反适配器场景: 对谓词(返回值是bool的函数对象)取反, 即可起到相反的作用, 比如用算法总的sort()排序
	not1: 对一元函数对象取反
		struct MyPrint {
			void operator()(int v) {
				cout << v << " ";
			}
		};

		struct GreaterThenFive : public unary_function<int, bool> {
			bool operator()(int v) const {
				return v > 5;
			}
		};

		int main(int argc, char* argv[])
		{
			vector<int> v;
			for (int i = 0; i < 10; i++)
			{
				v.push_back(rand() % 100);
			}
			for_each(v.begin(), v.end(), MyPrint());
			cout << endl;
			// 返回第一个大于5的元素的迭代器
			vector<int>::iterator it = find_if(v.begin(), v.end(), GreaterThenFive());
			// 返回小于等于5的元素的迭代器
			vector<int>::iterator it2 = find_if(v.begin(), v.end(), not1(GreaterThenFive()));
			cout << *it << endl;
			if (it2 == v.end())
			{
				cout << "没有找到" << endl;
			}
			else {
				cout << *it2 << endl;
			}
			return 0;
		}

	not2: 对二元函数对象取反
		struct MyCompare : public binary_function<int,int,bool>
		{
			bool operator()(int v1, int v2) const{
				// 降序排序
				return v1 > v2;
			}
		};
		struct MyPrint {
			void operator()(int v) {
				cout << v << " ";
			}
		};

		int main(int argc, char* argv[])
		{
			vector<int> v;
			for (int i = 0; i < 10; i++)
			{
				v.push_back(rand() % 100);
			}
			for_each(v.begin(), v.end(), MyPrint());
			cout << endl;
			//sort(v.begin(), v.end(), MyCompare()); // 降序 ****
			sort(v.begin(), v.end(), not2(MyCompare())); // 升序 ****
			for_each(v.begin(), v.end(), MyPrint());
			cout << endl;

			return 0;
		}

	ptr_fun: 将普通函数修饰成函数对象
		void MyPrint2(int val) {
			cout << val << " ";
		}
		void MyPrint3(int val, int val2) {
			cout << val + val2 << " ";
		}

		int main(int argc, char* argv[])
		{
			vector<int> v;
			for (int i = 0; i < 10; i++)
			{
				v.push_back(rand() % 100);
			}
			// 普通函数直接作为第三个参数也是可以的, 但是这个普通函数只能接收第一个参数
			for_each(v.begin(), v.end(), ptr_fun(MyPrint2));
			cout << endl;
			// ptr_fun将普通函数转为函数对象之后, 就可以传入第二个参数(普通函数转为了二元函数对象), bind2nd会将二元函数对象转换为一元函数对象作为参数
			for_each(v.begin(), v.end(), bind2nd(ptr_fun(MyPrint3), 10000));
			return 0;
		}


	当容器中存放的是对象或者对象指针, 我们希望for_each算法打印的时候, 调用类对象自己提供的打印函数, 就将类对象的打印函数转为函数对象
	mem_fun: 修饰成员函数(容器中是指针)
		int main(int argc, char* argv[])
		{
			vector<Person*> v;
			Person p1(1, 2), p2(3, 4), p3(5, 6), p4(7, 8);
			v.push_back(&p1);
			v.push_back(&p2);
			v.push_back(&p3);
			v.push_back(&p4);
			for_each(v.begin(), v.end(), mem_fun(&Person::Show)); // 格式: &类名::函数名
			return 0;
		}


	mem_fun_ref: 修饰成员函数(容器中是对象)
		int main(int argc, char* argv[])
		{
			vector<Person> v;
			Person p1(1, 2), p2(3, 4), p3(5, 6), p4(7, 8);
			v.push_back(p1);
			v.push_back(p2);
			v.push_back(p3);
			v.push_back(p4);
			for_each(v.begin(), v.end(), mem_fun_ref(&Person::Show)); // 格式: &类名::函数名
			return 0;
		}


=================================C++进阶 查找算法===================================
1.find()
	1.1 基本用法
	vector<int>::iterator ret = find(v.begin(), v.end(), 5);
	
	2.2 find内部实现使用的是"=="对元素进行对比, 所以如果容器中是对象的话对象所属的类需要重载"=="操作符
	class Person{
	public:
		Person(int age, int id):age(age), id(id){}
		bool operator==(Person p) const {
			return p.id == this->id && p.age == this->age;
		}
	public:
		int age;
		int id;
	}

2.binary_search() 二分查找法(必须是有序的序列, 比如是升序的话去查找3, 现在中间取一个数x, 如果x大于3的话就去x的左边找)

3.adjacent_search() 找到相邻重复的元素
vector<int>::iterator it = adjacent_find(v.begin(), v.end());

4.find_if() 第三个参数传入一个回调函数作为查找条件, 返回满足条件的第一个元素的迭代器

5.count() 查找某个元素出现的次数
int num = count(v.begin(), v.end(), 9); // 返回v中9出现的次数

6.count_if() 第三个参数传入一个回调函数作为查找条件, 返回满足条件的元素的个数


=================================C++进阶 遍历的几种方式===================================
#include <algorithm>
1.transform() 将一个容器中的元素(通过回调函数可对元素进行一些处理再) 搬运到 另一个容器中
struct MyPlus{
	int operator()(int val){
		return val;
	}
}

void test01(){
	vector<int> v1;
	vector<int> v2;
	v2.resize(v1.size()); // 开辟空间
	for(int i = 0; i < 10; i++){
		v1.push_back(i);
	}
	// 将v1中的元素通过MyPlus函数对象的处理, 放到v2中
	transform(v1.begin(), v1.end(), v2.begin(), MyPlus());
}



=================================C++进阶 数据结构>>基本概念===================================
数据结构主要: 研究非数值计算问题的程序中的操作对象以及他们之间的关系, 不是研究复杂的算法
数据结构 是计算机存储 组织数据的方式

2.大O表示法
// 3表示算法步骤 => 算法步骤是常数项箭头右边的值就为1
O(3) => O(1)

//2的x次方 = n; x = logan
O(logN)

如果统计一个算法的步骤是: 
1 + n + n~2 + n(n+1)/2
= 1 + n + n~2 + n~2/2 + n/2
= n~2*3/2 + n*3/2 + 1
只看最高次幂
O(n~2)



#pragma region 动态数组的实现
typedef struct Dynamic_Array
{
	int* pAddr;
	int capacity;
	int size;
}Dynamic_Array;

// 动态数组的初始化
Dynamic_Array* Dynamic_Array_Init() {
	Dynamic_Array* arr = NULL;
	arr = (Dynamic_Array*)malloc(sizeof(Dynamic_Array));
	if (arr)
	{
		arr->capacity = 20;
		arr->size = 0;
		arr->pAddr = (int*)malloc(sizeof(int) * arr->capacity);		
	}
	return arr;
}

// 打印
void Print_Array(Dynamic_Array* arr) {
	if (arr == NULL)
	{
		return;
	}

	for (int i = 0; i < arr->size; i++)
	{
		printf("%d ", *(arr->pAddr + i));
	}
	printf("\n");
}

// 释放动态数组的内存
void FreeSpace_Array(Dynamic_Array* arr) {
	if (arr->pAddr != NULL)
	{
		free(arr->pAddr);
	}
	free(arr);
}

// 清空数组
void Clear_Array(Dynamic_Array* arr) {
	if (arr == NULL)
	{
		return;
	}
	arr->size = 0;

}

// 获得动态数组的容量
int Capacity_Array(Dynamic_Array* arr) {
	if (arr == NULL)
	{
		return -1;
	}
	return arr->capacity;
}

// 获得动态数组的当前元素个数
int Count_Array(Dynamic_Array* arr) {
	if (arr == NULL)
	{
		return -1;
	}
	return arr->size;
}

// 获得动态数组某个位置的元素
int GetValue_Array(Dynamic_Array* arr, int pos) {
	if (arr == NULL)
	{
		return -1;
	}
	return arr->pAddr[pos];
}

// 插入
void PushBack_Array(Dynamic_Array* arr, int value) {
	if (arr == NULL)
	{
		return;
	}
	if (arr->size == arr->capacity)
	{
		// 新开辟一块2倍的空间
		int* tmp = (int*)malloc(sizeof(int) * arr->capacity * 2);
		if (tmp == NULL)
		{
			return;
		}
		// 拷贝数据
		memcpy(tmp, arr->pAddr, arr->capacity * sizeof(int));
		// 释放数组就空间, 重新指向新空间
		free(arr->pAddr);
		arr->pAddr = tmp;		
		// 更新容量
		arr->capacity = arr->capacity * 2;
	}
	arr->pAddr[arr->size] = value;
	arr->size++;
}

// 根据位置删除元素
void RemoveByPos_Array(Dynamic_Array* arr, int pos) {
	if (arr == NULL)
	{
		return;
	}
	if (pos < 0 || pos >= arr->size)
	{
		return;
	}
	for (int i = pos; i < arr->size - 1; i++)
	{
		arr->pAddr[i] = arr->pAddr[i + 1];
	}
	arr->size--;
}

// 根据值删除元素
void RemoveByValue_Array(Dynamic_Array* arr, int value) {
	if (arr == NULL)
	{
		return;
	}
	// 找值的位置
	int pos = -1;
	for (int i = 0; i < arr->size; i++)
	{
		if (arr->pAddr[i] == value)
		{
			pos = i;
			break;
		}
	}
	RemoveByPos_Array(arr, pos);
}
#pragma endregion


int main(int argc, char* argv[])
{
	Dynamic_Array* arr = Dynamic_Array_Init();
	for (int i = 0; i < 20; i++)
	{
		PushBack_Array(arr, i);
	}
	for (int i = 0; i < 20; i++)
	{
		PushBack_Array(arr, 20 + i);
	}	
	RemoveByPos_Array(arr, 2);
	RemoveByValue_Array(arr, 3);
	Print_Array(arr);
	FreeSpace_Array(arr);
	return 0;
}



=================================C++进阶 数据结构>> 用C语言实现单向链表/线性表的链式存储:不连续的内存空间组成===================================
#pragma region 单向链表的实现-线性表的链式存储-不连续的内存空间组成
// 链表节点结构体
typedef struct LINKNODE {
	void* data; // 指向任何类型的数据
	struct LINKNODE* next;
}LinkNode;
// 链表结构体,存储一个链表节点作为链表头, 通过这个链表头就可以找到其余所有的元素
typedef struct LINKLIST {
	LinkNode* head;
	int size; // 元素个数
	// 链表每加一个节点都会新开辟一个空间,不需要容量的概念
}LinkList;
// 创建一个打印函数 指针, 用户调用api的时候根据数据类型实现符合此函数指针类型的函数
typedef void(*PRINTLINKNODE)(void*);

// 初始化链表
LinkList* Init_LinkList() {
	LinkList* list = (LinkList*)malloc(sizeof(LinkList));
	if (list != NULL)
	{
		list->size = 0;
		list->head = (LinkNode*)malloc(sizeof(LinkNode));
		if (list->head != NULL)
		{
			list->head->data = NULL;
			list->head->next = NULL;
			return list;
		}
	}		
}

// 指定位置插入
void Insert_LinkList(LinkList* list, int pos, void* data) {
	if (list == NULL || data == NULL )
	{
		return;
	}
	if (pos < 0 || pos > list->size)
	{
		pos = list->size;
	}
	// 创建新的节点
	LinkNode* new_node = (LinkNode*)malloc(sizeof(LinkNode));
	if (new_node == NULL)
	{
		return;
	}
	new_node->data = data;
	new_node->next = NULL;
	if (pos == 0)
	{
		list->head = new_node;
	}
	else {
		// 查找pos的前一个节点
		LinkNode* pre_node = list->head;
		for (int i = 0; i < pos - 1; i++)
		{
			pre_node = pre_node->next;
		}
		// 新节点入链表
		new_node->next = pre_node->next;
		pre_node->next = new_node;
	}
	list->size++;
}

// 删除指定位置的值
void RemoveByPos_LinkList(LinkList* list, int pos) {
	if (list == NULL)
	{
		return;
	}
	if (pos < 0 || pos >= list->size)
	{
		return;
	}
	// 查找pos的前一个节点
	LinkNode* pre_node = list->head;
	for (int i = 0; i < pos - 1; i++)
	{
		pre_node = pre_node->next;
	}
	// 让前一个节点链向下一个节点, 再释放掉当前节点
	LinkNode* current_node = pre_node->next;
	pre_node->next = current_node->next;
	free(current_node);

	list->size--;
}

// 获取链表的长度
int Size_LinkList(LinkList* list) {
	return list->size;
}

// 查找
int Find_LinkList(LinkList* list, void* data) {
	if (list == NULL || data == NULL)
	{
		return -1;
	}
	// 遍历查找
	LinkNode* node = list->head;
	//bool f = node->data == data;
	int i = 0;
	while (node)
	{
		if (node->data == data)
		{
			break;
		}		
		/*f = node->data == data;*/				
		node = node->next;
		if (node == NULL)
		{		
			return -1;
		}
		i++;
	}
	return i;
}

// 返回第一个节点
void* Front_LinkList(LinkList* list) {
	return list->head;
}

// 打印链表节点
void Print_LinkList(LinkList* list, PRINTLINKNODE print) {
	if (list == NULL)
	{
		return;
	}
	LinkNode* node = list->head;
	while (node)
	{
		print(node->data);
		node = node->next;
	}
}

// 释放链表内存
void FreeSpace_LinkList(LinkList* list) {
	if (list == NULL)
	{
		return;
	}
	LinkNode* node = list->head;	
	while (node != NULL)
	{
		LinkNode* tmp_next = node->next;
		free(node);
		node = tmp_next;
	}

	free(list);
}

// 定义打印Person实例的函数
void Print_Person(void* data) {
	Person* p = (Person*)data;
	printf("年龄: %d, 编号: %d\n", p->age, p->id);
}

// 测试
void test_link_list() {
	LinkList* list = Init_LinkList();
	Person p1(18, 1), p2(19, 2), p3(20, 3), p4(22, 4);
	// 数据插入链表
	Insert_LinkList(list, 0, &p1);
	Insert_LinkList(list, 1, &p2);
	Insert_LinkList(list, 2, &p3);
	Insert_LinkList(list, 3, &p4);

	Print_LinkList(list, Print_Person);

	FreeSpace_LinkList(list);
}
#pragma endregion


=================================C++进阶 数据结构>> 用C语言实现企业链表===================================
思路: 先创建一个最简单的链表元素(相当于父类)组成链表, 然后创建的数据对象中包含了链表的元素对象, 这个数据相当于子类了(有了链表的能力, 具体实现方式是将数据指针[子类]转换为链表元素指针[父类])
#pragma region C语言实现企业链表
// 企业链表节点
typedef struct ADLINKNODE{
	struct ADLINKNODE* next;
}AdLinkNode;
// 企业链表
typedef struct ADLINKLIST {
	// head虽然和链表的单位元素类型一致, 但是head不存放数据, head.next为链表的第一个元素
	AdLinkNode head;
	int size;
}AdLinkList;

typedef void(*PRINTADNODE)(AdLinkNode*);

// 初始化链表;
AdLinkList* Init_AdLinkList() {
	AdLinkList* list = (AdLinkList*)malloc(sizeof(AdLinkList));
	if (list == NULL)
	{
		return NULL;
	}
	list->head.next = NULL;
	list->size = 0;
	return list;
}

// 插入链表
void Insert_AdLinkList(AdLinkList* list, int pos, AdLinkNode* data) {
	if (list == NULL || data == NULL)
	{
		return;
	}
	if (pos<0 || pos > list->size)
	{
		pos = list->size;
	}
	// 查找插入位置的前一个元素(索引是pos-1)
	AdLinkNode* prev_node = &(list->head);
	for (int i = 0; i < pos; i++)
	{
		prev_node = prev_node->next;
	}
	// 插入新节点
	data->next = prev_node->next;
	prev_node->next = data;	

	list->size++;
}

// 删除
void Remove_AdLinkList(AdLinkList* list, int pos) {
	if (list == NULL)
	{
		return;
	}
	if (pos < 0 || pos >= list->size)
	{
		return;
	}
	// 链表head.next指向链表的第一个元素
	AdLinkNode* pCurrent = &(list->head);
	// 循环后, 得到索引是(pos-1)的元素节点
	for (int i = 0; i < pos; i++)
	{
		pCurrent = pCurrent->next;
	}
	// 删除节点
	pCurrent->next = pCurrent->next->next;
	list->size--;
}

// 查找
int Find_AdLinkList(AdLinkList* list, AdLinkNode* data, COMPARENODE compare) {
	if (list == NULL || data == NULL)
	{
		return -1;
	}
	// 从第一个元素开始比较
	AdLinkNode* current_node = list->head.next; 
	int index = 0;
	int f = -1;
	while (current_node)
	{
		if (compare(current_node, data) == 0)
		{
			f = index;
			break;
		}
		current_node = current_node->next;
		index++;
	}
	return f;
}

// 返回链表大小
int Size_AdLinkList(AdLinkList* list) {
	return 0;
}

// 打印
void Print_AdLinkList(AdLinkList* list, PRINTADNODE print) {
	if (list == NULL)
	{
		return;
	}
	AdLinkNode* pCurrent = list->head.next;
	while (pCurrent)
	{
		print(pCurrent);
		pCurrent = pCurrent->next;
	}
}

// 释放
void FreeSpace_AdLinkList(AdLinkList* list) {
	if (list == NULL)
	{
		return;
	}
	free(list);
}

// 测试
typedef struct STUDENT {
	AdLinkNode node;
	char name[64];
	int age;
}Student;

void MyPrint(AdLinkNode* data) {
	Student* s = (Student*)data;
	printf("姓名: %s, 年龄: %d\n", s->name, s->age);
}

int MyCompare(AdLinkNode* node1, AdLinkNode* node2) {
	Student* s1 = (Student*)node1;
	Student* s2 = (Student*)node2;
	if (s1->age == s2->age && strcmp(s1->name, s2->name) == 0)
	{
		return 0;
	}
	return -1;
}

void test_advance_linklist() {
	// 创建链表
	AdLinkList* list = Init_AdLinkList();
	// 创建数据
	Student s1, s2, s3, s4, s5;
	strcpy(s1.name, "zhangsan");
	strcpy(s2.name, "lisi");
	strcpy(s3.name, "wangwu");
	strcpy(s4.name, "zhaoliu");
	strcpy(s5.name, "tianqi");
	s1.age = 10;
	s2.age = 12;
	s3.age = 14;
	s4.age = 16;
	s5.age = 18;
	// 将节点插入链表
	Insert_AdLinkList(list, 0, (AdLinkNode*)&s1);
	Insert_AdLinkList(list, 1, (AdLinkNode*)&s2);
	Insert_AdLinkList(list, 2, (AdLinkNode*)&s3);
	Insert_AdLinkList(list, 3, (AdLinkNode*)&s4);
	Insert_AdLinkList(list, 4, (AdLinkNode*)&s5);
	Print_AdLinkList(list, MyPrint);
	Student finded_student;
	strcpy(finded_student.name, "wangwu");
	finded_student.age = 14;

	int index = Find_AdLinkList(list, (AdLinkNode*)&finded_student, MyCompare);
	printf("pos: %d\n", index);
	FreeSpace_AdLinkList(list);
}
#pragma endregion


=================================C++进阶 数据结构>> 用C语言基于企业链表实现循环链表===================================
#pragma region C语言实现循环链表-基于企业链表
// 循环链表节点
typedef struct CIRCLELINKNODE {
	struct CIRCLELINKNODE* next;
}CircleLinkNode;

// 循环链表
typedef struct CIRCLELINKLIST {
	// head不保存数据, 初始化的时候, head指向自己, head.next为链表的第一个元素节点
	CIRCLELINKNODE head;
	int size;
}CircleLinkList;

// 比较函数 指针(回调函数)
typedef int(*COMPARECIRCLELINKNODE)(CircleLinkNode*, CircleLinkNode*);

// 打印函数 指针(回调函数)
typedef void(*PRINTCIRCLELINKNODE)(CircleLinkNode*);

#define CIRCLELINKLIST_TRUE 1
#define CIRCLELINKLIST_FALSE 0

// 初始化函数
CircleLinkList* Init_CircleLinkList() {
	CircleLinkList* list = (CircleLinkList*)malloc(sizeof(CircleLinkList));
	if (list == NULL)
	{
		return NULL;
	}
	list->head.next = &(list->head);
	list->size = 0;
	return list;
}

// 插入函数
void Insert_CircleLinkList(CircleLinkList* list, int pos, CircleLinkNode* data) {
	if (list == NULL || data == NULL)
	{
		return;
	}
	if (pos<0 || pos > list->size)
	{
		pos = list->size;
	}
	// 查找要插入位置的上一个节点, 索引为(pos-1)的节点
	CircleLinkNode* prev_node = &(list->head);
	for (int i = 0; i < pos; i++)
	{
		prev_node = prev_node->next;
	}

	data->next = prev_node->next;
	prev_node->next = data;
	list->size++;
}

// 获得第一个元素
CircleLinkNode* Front_CircleLinkList(CircleLinkList* list) {
	if (list == NULL || list->size <= 0)
	{
		return NULL;
	}
	return list->head.next;
}

// 根据位置删除
void RemoveByPos_CircleLinkList(CircleLinkList* list, int pos) {
	if (list == NULL)
	{
		return;
	}
	if (pos < 0 || pos >= list->size)
	{
		return;
	}
	CircleLinkNode* prev_node = &(list->head);
	for (int i = 0; i < pos; i++)
	{
		prev_node = prev_node->next;
	}
	// 缓存当前节点, 此节点不是框架申请的, 所以这里最好不要释放掉, 所有的节点都是用户malloc出来的, 让用户去管理即可
	CircleLinkNode* current_node = prev_node->next;
	prev_node->next = prev_node->next->next;
	/*free(current_node);*/
	list->size--;
}

// 根据值删除
void RemoveByValue_CircleLinkList(CircleLinkList* list, CircleLinkNode* data, COMPARECIRCLELINKNODE compare) {
	if (list == NULL || data == NULL)
	{
		return;
	}
	CircleLinkNode* current_node = list->head.next;
	CircleLinkNode* prev_node = &(list->head);
	while (current_node != &(list->head))
	{		
		if (compare(current_node, data) == CIRCLELINKLIST_TRUE)
		{
			prev_node->next = current_node->next;
			break;
		}
		prev_node = current_node;
		current_node = current_node->next;
	}
}

// 获取链表的长度
int Size_CircleLinkList(CircleLinkList* list) {
	if (list == NULL)
	{
		return -1;
	}
	return list->size;
}

// 判断是否为空
int IsEmpty_CircleLinkList(CircleLinkList* list) {
	if (list->size == 0)
	{
		return CIRCLELINKLIST_TRUE;
	}
	else {
		return CIRCLELINKLIST_FALSE;
	}
}

// 查找数据的索引
int Find_CircleLinkList(CircleLinkList* list, CircleLinkNode* data, COMPARECIRCLELINKNODE compare) {
	if (list == NULL || data == NULL)
	{
		return -1;
	}
	CircleLinkNode* current_node = list->head.next;
	int index = 0;
	while (current_node != &(list->head))
	{
		if (compare(current_node, data) == CIRCLELINKLIST_TRUE)
		{
			return index;
		}
		current_node = current_node->next;
		index++;
	}
	return -1;
}

// 打印节点
void Print_CircleLinkList(CircleLinkList* list, PRINTCIRCLELINKNODE print) {
	if (list == NULL)
	{
		return;
	}
	CircleLinkNode* current_node = list->head.next;
	while (current_node != &(list->head))
	{
		print(current_node);
		current_node = current_node->next;
	}
}

// 释放内存, 只释放框架自己malloc出来的空间, 即CircleLinkList的空间, 节点空间属于用户创建的, 由用户处理
void FreeSpace_CircleLinkList(CircleLinkList* list) {
	if (list == NULL)
	{
		return;
	}
	free(list);
}

// 测试
// 测试自定义数据
typedef struct TEACHER {
	CircleLinkNode node;
	char name[64];
	int age;
}Teacher;
// 定义符合打印函数指针的函数
void PrintCircleLinkNode(CircleLinkNode* data) {
	if (data == NULL)
	{
		return;
	}
	Teacher* t = (Teacher*)data;
	printf("name: %s, age: %d\n", t->name, t->age);
}
// 定义符合比较节点函数指针的函数
int CompareCircleLinkNode(CircleLinkNode* data1, CircleLinkNode* data2) {
	if (data1 == NULL || data2 == NULL)
	{
		return CIRCLELINKLIST_FALSE;
	}
	Teacher* t1 = (Teacher*)data1;
	Teacher* t2 = (Teacher*)data2;
	if (strcmp(t1->name, t2->name) == 0 && t1->age == t2->age)
	{
		return CIRCLELINKLIST_TRUE;
	}
	else {
		return CIRCLELINKLIST_FALSE;
	}
}
void test_ciclelinklist() {
	CircleLinkList* list = Init_CircleLinkList();
	Teacher t1, t2, t3, t4, t5;
	strcpy(t1.name, "zhangsan");
	strcpy(t2.name, "lisi");
	strcpy(t3.name, "wangwu");
	strcpy(t4.name, "zhaoliu");
	strcpy(t5.name, "tianqi");
	t1.age = 21;
	t2.age = 22;
	t3.age = 23;
	t4.age = 24;
	t5.age = 25;
	// 数据入链表
	Insert_CircleLinkList(list, 0, (CircleLinkNode*)&t1);
	Insert_CircleLinkList(list, 1, (CircleLinkNode*)&t2);
	Insert_CircleLinkList(list, 2, (CircleLinkNode*)&t3);
	Insert_CircleLinkList(list, 3, (CircleLinkNode*)&t4);
	Insert_CircleLinkList(list, 4, (CircleLinkNode*)&t5);

	Teacher t;
	t.age = 23;
	strcpy(t.name, "wangwu");
	// RemoveByValue_CircleLinkList(list, (CircleLinkNode*)&t, CompareCircleLinkNode);
	int wangwu_pos = Find_CircleLinkList(list, (CircleLinkNode*)&t, CompareCircleLinkNode);
	printf("wangwu's index is %d\n", wangwu_pos);

	Print_CircleLinkList(list, PrintCircleLinkNode);
	FreeSpace_CircleLinkList(list);
}
#pragma endregion


=================================C++进阶 数据结构>> 约瑟夫问题-循环链表的典型应用===================================
例题: m个人围城一个圆圈, 首先第一个人从1开始一个人一个人顺时针报数, 报到第n个人的时候, 令其出列. 然后再从下一个人开始顺时针报数, 报到第n个人, 再令其出列, ..., 如此下去, 求出列顺序




























爱,死亡和机器人
自修室
曼达洛人
致命女人
切尔诺贝利




猪牛羊一起进超市买东西,然后猪和牛都被打了, 为什么羊没有被打?

曹操擒住吕布问道: "你临死前还有什么愿望吗?"
吕布说到: "我不想死..."
曹操十分叹息的说到: "有时候把愿望说出来就不灵了"


某日, 花木兰昔日的战友来到家中做客, 看见花木兰正在刺绣, 这刺绣上的女子和花木兰有几分相似, 但是战友又不太敢确定, 这刺绣上是否是花木兰的母亲, 于是战友试探性地问道: "你在秀尼玛呢???"

今天中午我吃干锅牛蛙的时候, 隔壁桌小女孩问她妈妈: "妈妈, 小青蛙回不了家它妈妈会不会着急啊?", 妈妈瞬间愣在那里, 我的筷子也瞬间停顿了, 面对这么善良的问题, 我们都不好意思下口了, 这时候老板过来解围了: "没事的它们全家都在这里"

有一天你在沙漠迷路了非常渴, 这时候呢有两杯水, 一杯尿一杯毒药, 你选哪个