=========================================================================
1.p[i]和*(p+i)相同
const修饰的结构体指针变量: 变量能修改, 但是指针指向的内存不能修改

2.windows平台的文本换行符"\r\n"
====hello world====
111
222
333

Linux平台的文本换行符"\n"
在windows平台下以文本方式打开文件: 读取文件, 会将"\r\n"换成"\n", 写入文件的时候, 会将"\n"换成"\r\n"
如果以二进制方式打开文件, 那么就不会有上面的转换过程

3.数组在函数间的传递, 注意实参类型(数组), 形参类型(指针)
int a[] = {2, 10, 8, 7, 5, 4, 1, 3, 6, 9};
int n = sizeof(a)/sizeof(a[0]);
// 这里的实参a是数组类型, choose_sort()的第一个参数(形参)是指针类型, 参数传递过程实际上是
// 数组(a)复制了一份赋值给a, 而不是把地址传递过去了
choose_sort(a, n);

4.4个字节大小的内存空间叫做整型

5.字符'\0'和数字0是等价的

6.char str[] = "abc"; // str是首地址,常量,不能作为指针使用,"abc"在文字常量区拷贝一份到栈区
  char *str = "abc"; // str是指针, 直接指向文字常量区的"abc"

7.栈的生长方向,递减,从高地址往低地址分配,首地址在低位(指针进行加法运算得到首地址后面的内存), 后进先出, 堆相反

fgets() 
1.从文件中(参数3:文件指针,文件可以是设备文件or磁盘文件) 读取一定长度的字节(参数2: int) 存放到内存的字节数组中(参数1: char *)
2.当参数3是stdin的时候(关联键盘的设备文件), 直到键盘输入回车, 从而从键盘读取输入的一行内容

fputs()
1.将一个字符串(参数1: char *)写入到一个文件指针(参数2: FILE */stdout)所关联的文件中(磁盘文件or设备文件)

sscanf()
1.有点类似于拆包,将一个字符串中的字符按类型以一定的格式提取出来赋值给新的变量(从字符串中获取字节)
char buf[100] = "1+2=\n";
int a, b;
char ch;
sscanf(buf, "%d%c%d=\n", &a, &b, &ch);

fprintf()
1.以格式化的方式将字符数组(参数2)放到文件中(FILE *)



a=0;
a++ && aa++;
a=?

========================================================================

===================================指针=====================================
只有使用“&数组名”时，才是取数组首地址；直接打印数组名或者&数组名[0]都是取得数组首元素地址
"&数组首元素变量名"结果是变量的地址(此变量占据的是数组之外的另外一块内存空间)

char *tmp;
char **p = &tmp;  //ok

//str首元素 是什么类型？ char *
//&str[0], 代表首元素地址，str等价于&str[0](数组名字就是数组首元素地址)
char *str[] = {"abc", "micke", "hello"}; //数组每一项都是char *类型（"abc"就是"abc"首元素地址）
char **p = str;  //char **指向char *
char **p = &str[0]

//下面三者等级， 编译器都当做char **p处理， 形参中的数组都是指针(数组名为元素首地址)，不是数组
void fun(char **p);
void fun(char *p[]);
void fun(char *p[100]);

void fun(int a[]);
void fun(int a[100]);
void fun(int *a)

//p2是数组
char *p2[] = {"abc", "mike", "hello"}
//p2是指针
char * * p2;

===================================静态的局部变量=====================================
存储在"data区"(函数中的局部静态变量在函数调用前就分配空间了,程序结束前不会释放)
初始化语句(static int a = 0;)只会执行一次,但是可以赋值多次    ****
只能用常量初始化(不要用变量给它赋值,因为变量只有程序执行到才会给变量分配空间,而它一开始就分配了空间) ****
在编译阶段就已经分配内存空间,函数没有调用前它就已经存在
如果没有被初始化,默认值为0(普通局部变量是随机数)

===================================普通全局变量=====================================
在定义之前若要使用可以声明(extern int a;) 可以声明多次, extern为声明的关键字
    extern int b = 10; //err,只有声明,没有定义,无法给变量赋值
在编译阶段已经分配空间(函数没有执行前),只有在整个程序结束才自动释放

缺陷:
    如果定义一个全局变量,没有赋值(初始化),无法确定是定义还是声明
    如果定义一个全局变量,同时初始化,这个肯定是定义

=================================声明一个全局变量=====================================
定义在函数外面,其他文件也都能用,一个全局变量多个文件中只能定义一次
如果要使用另一个.c文件中定义的全局变量, 需要声明一下,虽然可以不用extern,带上extern比较清晰
extern int a;
这种方式可行,但是使用头文件的方式(声明所有的变量和函数)更加优秀

=================================声明一个函数=========================================
//假设想要调用另一个.c文件中的一个test()函数,需要声明,声明的时候有没有extern无所谓
extern void test(); 或者 void test();
这种方式可行,但是使用头文件的方式(声明所有的变量和函数)更加优秀

=================================全局静态变量=========================================
跟普通的全局变量相比,作用域不一样(文件作用域)
extern关键字只适用于普通全局变量

一个文件有且只有一个static全局变量的定义
static全局变量只能在当前文件中使用

=================================内存分区/内存四区=========================================
gcc编译器:
    1.预处理,头文件展开,宏定义展开,条件编译,去掉注释
    2.编译,生成汇编代码
    3.生成目标代码.o
    4.关联链接,生成可执行程序
生成a.out文件, 终端:size a.out
    text    data    bss     dec     hex     filename
    1099    544     8       1651    673     a.out

a.说明编译生成可执行程序后,程序执行前,就已经"确定"(并没有加载到内存)了这几个 内存分区,虽然分区确定了,但是没有加载内存
程序只有运行时才会加载内存:
    text(代码区): 只读,函数
    data: 初始化的数据,全局变量和静态变量, 文字常量区(只读)
    bss: 没有初始化的数据,全局变量和静态变量
b.当运行程序,加载内存,首先根据前面确定的内存分区(text,data,bss)先加载, 然后额外加载两个区
    text(代码区): 只读,函数
    data: 初始化的数据,全局变量和静态变量, 文字常量区(只读)
    bss: 没有初始化的数据,全局变量和静态变量
    stack(栈区): 普通局部变量
    heap(堆区): 手动申请空间,手动释放, 整个程序结束,系统也会自动回收,如果没有手动释放,程序也没有结束
        这个堆区空间不会自动释放


堆区(heap): Malloc/new free/delete, 操作系统管理
栈区(stack): 程序局部变量
    char str[] = "abcd"; // 现在文字常量区放一个"abcd\0", 然后拷贝一份到栈区"abcd\0"
全局区(global): 常量和全局变量, 操作系统管理
    全局变量
    静态变量
    文字常量区
代码区(code): 操作系统管理



=================================打字游戏=========================================
1.生成随机字母('a'+0~25)

// 用随机字母填充字符数组, 字符数组的总长度(包含结束符)为宏定义MAX(51个)
// str 需要填充的字符数组的首地址 
void fill_char_array_with_rand_char(char *str)
{
    srand((unsigned int)time(NULL)); //随机种子
    int i = 0;
    for (i = 0; i < MAX - 1; i++)
    {
        // rand() % 26, 得到0~25的一个随机数
        *(str + i) = rand() % 26 + 'a';
    }

    *(str + MAX - 1) = '\0';
}


=================================结构体=========================================
struct Student
{
    char name[50];
    int age;
    int score;
};
类型名: struct Student; (别忘了struct)
变量名: struct Student stu;
//stu.name = "mike"; //error, 因为数组名是常量, 只读
strcpy(stu.name, "mike");
stu.age = 18;
stu.score = 60;

只有定义的时候才能初始化:
struct Student stu2 = {"mike", 18, 60};

如果是指针变量, 使用"->":
struct Student *p;
p = &stu2; //指针有合法指向, 才能操作结构体成员
strcpy(p->name, "mike");
p->age = 18;
p->score = 99;

任何结构体变量都可以用"."或者"->"操作成员
(&stu2)->age = 18; //求得变量的指针(地址)时用 "->"
(*p).age = 18; //通过指针前加"*", 直接操作结构体内存空间时用"."

相同类型的2个结构体变量可以相互赋值
struct Student s1 = {"mike", 18, 88};
struct Student S2;
s2 = s1; //值传递, 两个变量是没有关系的独立内存

指针指向堆区空间
struct Student *p;
p = (struct Student *)malloc(sizeof(struct Student));
if(p == NULL){
    printf("malloc error\n");
    return 0;
}   
...
if(p != NULL){
    free(p);
    p = NULL;
}


成员指向data区或者栈区或者栈区
struct Student{
    int age;
    char *name;
    int score;
};
int main(){
    struct Student s;
    s.age = 19;
    s.name = "mike"; // 指针变量保存字符串常量的首地址, 相当于char *p = "mike"; "mike"在文字常量区
    // char buf[100];
    // s.name = buf; //指向栈区空间
    // strcpy(s.name, "mike");

    // s.name = (char *)malloc((strlen("mike") + 1) * sizeof(char));  // 指向堆空间
    // strcpy(s.name, "mike");
    
}


=================================共用体(联合体)=========================================
union Test{
    unsigned char a;
    unsigned short b;
    unsigned int c;
    double d;
};

int main(){
    // 1.共用体的大小为最大成员的大小
    printf("%lu\n", sizeof(union Test)); // 8(double的长度)
    // 2.共用体公用一块内存, 所有成员的地址一样(首地址相同)
    union Test obj;
    printf("%p, %p, %p, %p\n", &obj, &ojb.a, &obj.b, &obj.c, &obj.d); //打印出的所有地址都相同
    
    // 3.给某个成员赋值, 会影响到另外的成员
    // 左边是高位, 右边是低位
    // 高位放高地址, 低位放低地址(小端)
    obj.c = 0x44332211; (16进制可以为每个字节赋值, 每两个16进制占一个字节, 因为一个字节8位,二进制最大能存储255个值,而两位的16进制最大数也是255)
    printf("obj.c = %x\n", obj.c); // 44332211 
    printf("obj.a = %x\n", obj.a); // 11
    printf("obj.b = %x\n", obj.b); // 2211

    obj.a = 0xaa;
    printf("obj.c = %x\n", obj.c); // 443322aa
    printf("obj.a = %x\n", obj.a); // aa
    printf("obj.b = %x\n", obj.b); // 22aa


}


=================================枚举 enum=========================================
主要作用是替代如下定义宏的方式:
#define MAX 51  // 定义宏
#define pink 0
#define red 1
#define green 2
#define white 3
#define yellow 4

枚举的方式:
// 里面的成员是一个标识符, 枚举常量
// 第一个成员如果没有赋值, 默认为0, 下一个成员比上一个多1
enum Color
{
    pink, red, green, white, yellow
};


=================================文件 概述=========================================
printf(); // 把内存中的值显示(写)到屏幕  
过程:
内存->缓冲区(存满一次提交)->屏幕(文件?)

scanf(); 
键盘(文件?)->缓冲区->内存变量

FILE 所有平台名字都一样, FILE是一个机构提类型, 里面的成员功能一样,不同平台成员的名字不一样.
FILE *fp
1. fp指针, 只调用了fopen(), 在堆区分配空间, 把地址返回给fp
2. fp指针不是指向文件, fp指针和文件关联, fp内部成员保存了文件的状态
typedef struct
{
    short level; //缓冲区"满"后者"空"的程度
    unsigned flags; //文件状态标识
    char fd; //文件描述符(其实就是一个整型)
    unsigned char hold; //如无缓冲区不读取字符
    short bsize; //缓冲区的大小
    unsigned char *buffer; //数据缓冲区的位置
    unsigned ar; //指针, 当前的指向
    unsigned istemp; //临时文件指示器
    short token; //用于有效性的检查
}

3. 不能直接对fp指针进行操作, 必须通过文件库函数来操作fp指针

4. 通过库函数操作fp指针, 对文件的任何操作, fp里面成员会相应的变化(系统自动完成)


=================================文件 分类(磁盘文件和设备文件)=========================================
磁盘文件
指一组相关数据的有序集合, 通常存储在外部介质(如磁盘)上, 使用时才调入内存
设备文件
在操作系统中, 把每一个与主机相连的输入/输出设备看做是一个文件, 把它们的输入输出等同于对磁盘文件的读和写


=================================文件 操作流程=========================================
1. 打开文件fopen()
2. 读写文件
    1) 按字符读写fgetc(), fputc()
    2) 按字符串(行)读写文件fgets(), fputs()
    3) 文件结尾判断 feof()
3. 关闭文件


读写文件, 需要fp指针(FILE *)结合相关库函数使用才行, fp指针指向的内存空间记录了目标文件的相关信息, printf()函数其实是针对屏幕的, 而屏幕也可以看做一个文件,
与屏幕也有个相关的"fp指针"(FILE *), 叫做"stdout", 将"stdout"关联到一个磁盘文件, 那么即可对磁盘文件进行操作

理解性代码(不用于执行)
printf("before aaaaa\n");  //内存中已经加载了文件相关信息的"stdout"指针, 通过"stdout"向屏幕写入字符串
fclose(stdout); //切断了"stdout"指针(FILE *)指向
stdout = fopen("./01.txt", "w"); //fopen()打开一个文件, 并返回"FILE *"类型的指针赋值给"stdout"
if(stdout == NULL)
{
    // 打开文件失败
    printf("fopen error!");
    return -1;
}
// "stdout"指针指向的内存区域已经关联到了"01.txt"文件, 所以此代码的意图是写入字符串到"01.txt"文件中
// 然而这里只是帮助我们理解磁盘文件和设备文件的区别的代码, 并不能执行成功!!!!
// 实际思路一样的, 但是更改指针指向和打开文件的库函数有所不同
printf("after bbbbbb\n"); 

系统编程的代码思路:
printf("before aaaaaa\n"); // printf()函数的作用是往"1"代表的设备(标准输出设备)中写内容
close(1);  // "1"是文件描述符 本来代表标准输出设备(屏幕), 关闭"1"就切断了"1" 和 "屏幕"的关联, "1" 处于空闲状态
int fd = open("01.txt", O_WRONLY, 0777); //打开文件, 并返回一个最小可用的 "数字"(即"1"), "数字fd"代表"目标文件"
printf("after bbbbbb\n"); // 此时"1"代表"01.txt"文件,而printf()会往"1"中写入字符串,所以字符串被写入"01.txt"文件中





=================================文件 打开和关闭=========================================
FILE * fopen(const char *filename, const char * mode)

此函数在堆空间开辟一块内存空间, 存储了FILE结构体, FILE结构体中的成员记录了目标文件的状态, 最后函数返回FILE结构体的
内存地址, 即FILE *类型的fp

代码:
FILE *fp = NULL;
// "w", 如果文件不存在, 新建, 如果文件存在,清空再打开
// "r", 如果文件不存在, 打开失败
// "w+", 读写模式, 清空文件再打开
// "a", 如果文件不存在, 新建, 如果文件存在,不清空内容,光标自动放在文件末尾
fp = fopen("./02.txt", "r");
if(fp == NULL){
    perror("fopen");
    return 0;
}


fclose(fp);
fp = NULL;
return 0;

=================================fputc()写文件=========================================
//fputc()写文件, 一次只能写入一个字符
fputc('h', fp);
fputc('e', fp);
fputc('l', fp);
fputc('l', fp);
fputc('o', fp);
//写入到屏幕的话将fp改成stdout即可
//写入26个字母
char ch = 'a';
while(ch <= 'z'){
    fputc(ch, fp);
    ch++;
}
//写入一个字符串
char buf[] = "abcdefghijklmn";
int i = 0;
int n = strlen(buf);
for(i=0; i<n; i++){
    fputc(buf[i], fp); //fputc(*(buf+i), fp);
}

=================================fgetc()读文件=========================================
char ch;
while(1)
{        
    ch = fgetc(fp);
    // 如果是文本文件,可以通过-1(EOF)判断文件是否结尾
    // 如果是二进制文件, 文件中会有很多的-1, 此时就不能通过-1判断文件是否结尾, feof()可判断任何文件结尾
    //if (ch == -1)
    //if (ch == EOF) // 系统的宏定义,即-1
    if(feof(fp)) // 如果到文件结尾返回真, 执行此文件之前必须读过了文件,因为函数会从读过的字符中判断,否则直接调用永远访问假
    {
        break;
    }
    printf("%d\n", ch);
}

=================================练习栗子 实现vi命令=========================================
//1.以写的方式打开文件, w, 路径为argv[1]
FILE *fp = fopen(argv[1], "w");

//从键盘读取内容fgets(), 键盘输入的关联指针是"stdin", 放入字符数组
//字符数组内容, 一个一个字符往文件里面写
char buf[1024];
while(1){
    // 默认遇到换行符, 便结束此次的读取工作, 换行符都放在buf中
    // 可以人为fgets()是按行读取的
    fgets(buf, sizeof(buf), stdin);
    if(strncmp(buf, ":wq", 3) == 0){
        break;
    }

    // 将读取到的内容写入文件
    int i = 0;
    while(buf[i] != '\0'){
        fputc(buf[i], fp);
        i++;
    }
}

//关闭文件
fclose(fp);


=================================fputs()=========================================
// 用法: 将字符串放到文件关联指针所关联的文件中去(可以是磁盘文件, 也可以是设备文件, 如屏幕)
char buf[] = "hello\n";
// 把buf的内容写到stdout所代表的文件中, 即显示屏幕
fputs(buf, stdout);

// fputs()写入文件, 只需要一个FILE *类型的指针即可
FILE *fp = fopen("tt11.txt", "w");
fputs("hello world\n", fp);
char *p = "bombomxiakalaka\n";
fputs(p, fp);


=================================fgets()=========================================
FILE *fp = fopen("tt11.txt", "r");
// 读文件
char buf[100];

// 1.从fp所关联的文件读取内容, 放到buf, 一次最大读取为(sizeof(buf) - 1), 因为要留一个放'\0'
// 2.遇到换行符, 文件结尾, 出错, 结束本次读取
fgets(buf, sizeof(buf), fp);
printf("buf=%s\n", buf);


=================================fprintf()=========================================
1.以格式化的方式将字符数组(参数2)放到文件中(参数1:FILE *)
FILE *fp = fopen("tt11.txt", "w+");

// 写文件fprintf()
int i = 0;
int n = 10;
int num = 0;
// 设置随机种子
srand((unsigned int)time(NULL));
for(i=0; i<n; i++){
    num = rand()%100;
    fprintf(fp, "%d\n", num);
}

=================================fscanf()=========================================
1.格式化的方式从文件中读取字节放到内存中
FILE *fp = fopen("tt11.txt", "r+");
int num;
fscanf(fp, "%d\n", &num);

=================================fwrite()=========================================
FILE *fp = fopen("tt11.txt", "w");

Student s1 = {18, "mike", 59};
// 参数1: &s1, 需要往文件写内容的变量首地址
// 参数2: sizeof(Student), 往文件写入内容的块大小
// 参数3: 1, 往文件写入内容的块数目
// ret: 返回值为写入成功时写入内容的块数目
int ret = fwrite(&s1, sizeof(Student), 1, fp);

=================================fread()=========================================
struct Student s[10];
// 参数1: 用于存储将要从文件读取的数据的内存空间的首元素地址
fread(s, 1, sizeof(struct Student)*4, fp);
for (int i = 0; i < 4; i++)
{
    printf("%d, %s, %d\n", s[i].age, s[i].name, s[i].score);
} 


=================================拷贝文件(cp命令)=========================================
// windows下默认把对象文件当做文本文件, 文本文件遇到特殊字符就会中断, 所以windows下打开文件的模式需要使用"rb", "wb",
// 加上"b"的话windows和Linux平台都将兼容
FILE * fp = fopen(argv[1], "rb"); // windows下使用"rb", Linux下使用"r"和"rb"等价
FILE * w_fp = fopen(argv[2], "wb"); // windows下使用"wb", Linux下使用"w"和"wb"等价
char buf[4*1024]; // 一次读取4k
int len;    
while (1)
{
    len = fread(buf, 1, sizeof(buf), fp);
    printf("len = %d\n", len);
    if (len == 0)
    {
        break;
    }
    fwrite(buf, 1, len, w_fp);
}
fclose(fp);
fclose(w_fp);


=================================随机位置的读写=========================================
long ftell(FILE *stream) 获取文件流(文件光标)的读写位置, 将光标放到文件末尾,在查看光标位置(即文件大小/字节)
void rewind(FILE *stream) 重置读写位置(光标)

int fseek(FILE *stream, long offset, int whence)
    whence有三个值:
        SEEK_SET: 从文件开头移动offset个字节
        SEEK_CUR: 从当前位置移动offset个字节
        SEEK_END: 从文件末尾移动offset个字节
fseek(fp, 0, SEEK_SET); 将光标移到 在开头便宜0个字节的位置, 回到开头的作用
fseek(fp, 100, SEEK_SET); 在开头向右便宜100个字节
fseek(fp, 100, SEEK_CUR); 在当前位置向右便宜100个字节
fseek(fp, 0, SEEK_END); 将光标移到 在结尾位置偏移0个字节(的位置), 即将光标移到文件末尾


目标文件中有三个struct Student类型的实例, 读取第三个struct Student类型的实例
struct Student s;
fseek(fp, sizeof(s)*2, SEEK_SET);
int ret = fread(&s, 1, sizeof(s), fp);
printf("ret=%d\n", ret);
printf("%d, %s, %d\n", s.age, s.name, s.score);


=================================文件的重命名和删除=========================================
int remove(const char *pathname) 返回值:成功0 失败-1
int rename(const char *oldpath, const char * newpath) 返回值:成功0 失败-1

=================================文件缓冲区=========================================
1. 默认情况下, 写入文件的数据, 其实是先写入到缓冲区, 缓冲区满了, 自动刷新缓冲区(数据写入文件)
2. 文件正常关闭, 缓冲区的数据也会写入文件
3. 缓冲区没有满的时候, 文件不关闭, 程序没有结束, 要实现实时刷新, 调用fflush
4. 程序正常关闭, 缓冲区的数据也会写入文件


=================================vs2010调试错误=========================================
错误	1	error LNK1123: 转换到 COFF 期间失败: 文件无效或损坏...
C:\Program Files\Microsoft Visual Studio 10.0\VC\bin



=================================选择排序=========================================
/*选择排序*/
int choose_sort(int *int_array, int n)
{
    int a[] = {2, 10, 8, 7, 5, 4, 1, 3, 6, 9};  
    int temp = 0;
    // printf("排序前:");
    // for (int i = 0; i < n; i++)
    // {
    //     printf("%d ", a[i]);
    // }
    // printf("\n");

    for (int i = 0; i < n - 1; i++)
    {
        for (int j = i+1; j < n; j++)
        {
            if (a[i] > a[j])
            {                
                temp = a[i];
                a[i] = a[j];
                a[j] = temp;
            }            
        }        
    }
    // printf("排序后:");
    for(int i = 0; i < n; i++){
        printf("%d ", a[i]);
    }
    printf("\n");
    return 1;
}

需要的地方调用:
    int a[] = {2, 10, 8, 7, 5, 4, 1, 3, 6, 9};
    int n = sizeof(a)/sizeof(a[0]);
    // 这里的实参a是数组类型, choose_sort()的第一个参数(形参)是指针类型, 参数传递过程实际上是
    // 数组(a)复制了一份赋值给a, 而不是把地址传递过去了
    choose_sort(a, n);


=================================数据类型的本质=========================================
类型(int, char...): 固定内存大小的别名(4个字节大小的内存空间叫做整型)
编译器可以根据类型 预算对象(变量)分配的内存空间大小
int a[10]; // 告诉编译器开辟一个4*10大小的内存空间
a: 数组名/数组首元素地址(首元素是int类型)/数组首地址, 一个元素4个字节, +1即size加4
&a: 整个数组的首地址一个数组4*10=40个字节, 所以+1即size加40


=================================份文件/多文件=========================================
1) 分文件时, 防止头文件重复包含
#pragma once

2) 让c代码可以在c++编译器编译运行
// __cplusplus是编译器提供好的宏, 不是自定义的
#ifdef __cplusplus
extern "C"{
#endif // __cplusplus

// 函数的声明

#ifdef __cplusplus
}
#endif // __cplusplus

=================================指针做参数输入输出特性=========================================
void fun(char **p /* in */){}
void fun2(char **p /* out */, int *len){
    if(p == NULL){
        return;
    }
    char *tmp = (char *)malloc(100);
    if(tmp == NULL){
        return;
    }
    strcpy(tmp, "abcd");

    // 间接赋值
    *p = tmp;
    *len = strlen(tmp);
}
int main(void){
    // 输入, 主调函数分配内存
    char buf[100] = {0};    
    fun(buf);

    // 输出, 被调用函数分配内存, 地址传递
    char *p = NULL;
    int len = 0;
    fun2(&p, &len);
}

=================================字符串包含/字符串是否包含/子字符串substr=========================================
利用strstr()标准库函数找出一个字符串中substr出现的个数
int str_contains(char * src, char * substr, int * count){
    while (src = strstr(src, substr))
    {
        (*count)++;
        src = src + strlen(substr);      
        if (*src == 0)
        {
            break;
        }        
    }
    return 0;
}
int main(void){
    char *p = "11abcd111122abcduuw98982abcd983387wfabcdqqq";
    char *substr = "abcd";    
    int count = 0;
    str_contains(p, substr, &n);
    printf("子字符串出现次数 = %d\n", count);
}


======================去除字符串首尾空格/去除字符串空格/两头堵模型/是否空格isspace()==========================
// 去处字符串inbuf首尾的空格, 去除空格后的字符串为outbuf, 成功返回0
int trim_space(char *inbuf, char *outbuf)
{
    if (inbuf == NULL || outbuf == NULL)
    {
        return -1;
    }
    
    char *p = inbuf;
    int begin = 0;
    int end = strlen(p) - 1;
    int n = 0; // 非空元素个数
    if (end < 0)
    {
        return -2;
    }
    //从左往右移动, 如果当前字符为空, 而且没有结束
    while (p[begin] == ' ' && p[begin] != 0)
    {
        begin++; //指针位置向右边移动一位
    }
    //从右往左移动, 如果当前字符为空
    while (p[end] == ' ')
    {
        end--; // 往左移动
    }
    n = end - begin + 1; // 非空元素个数        
    strncpy(outbuf, p + begin, n);
    outbuf[n] = 0;
    return 0;
}

int main(){
    char p1[] = "  hello   ";    
    char p1_out[50] = {0};    
    trim_space(p1, p1_out);
}


============================键值对字符串根据键获取值/可应用于配置文件===========================
// 根据键值对字符串("key1 =  value1")的键, 获取值(去空格)
int get_value_by_key(char *key_value_buf, char *key_buf, char *value_buf, int *value_buf_len)
{
    /*
    key_value_buf = "key1 =     value1";
    key_buf = "key1";        
    */
   if (key_buf == NULL || key_value_buf == NULL || value_buf == NULL || value_buf_len == NULL)
   {
       return -1;
   }
   char *p = NULL;
   // 查找匹配键值, "key1 =     value1"找"key1"
   p = strstr(key_value_buf, key_buf);
   if (p == NULL)
   {
       return -2;
   }
   // 找到key_buf, 重新设置起点, 跳过"key1", 即"key1 =     value1" => " =     value1";
   p = p + strlen(key_buf);
   // 查找"="
   p = strstr(p, "=");
   if (p == NULL)
   {
       return -3;
   }
   // 找到"="
   // p = p + 1;
   p++;
   int ret = trim_space(p, value_buf);
   if (ret != 0)
   {
       printf("trim_space error: %d\n", ret);
       return ret;
   }
   // 获取长度
   *value_buf_len = strlen(value_buf);
   return 0;
}


=================================const的使用===================================
从左往右看, 跳过类型, 看修饰谁
如果是*, 说明指针指向的内存不能改变
如果是指针变量, 说明指针的指向不能改变, 指针的值不能修改

MyStruct const *p;  // 指向内存的值不能变, 指针的值(指向的内存)可以改变
MyStruct * const p; // p的值(指向的内存)不能改变, 指向的内存的值可以改变

=================================二级指针和一级指针用于函数传参时的区别===================================

二级指针目的: 子函数中操作main()函数的void *类型的变量(主要是改变指针的值, 即指向内存)
若是需要改变指针内存的值, 一级指针即可


一级指针(跟值传递差不多), 参数传递过程为p2 = p1, p2的操作不影响p1
p1       main()函数中的指针p
-----
p2       子函数中的形参p

二级指针 p2指向p1, 通过p2可以操作p1(通过子函数操作main函数中的p1)
p1<-----      main()函数中的指针p void *
-----  |
p2----->       子函数中的形参p void **


=================================二维数组===================================
char b[30];
&b -> &b + 1    (首行地址)相差30
b -> b + 1      (首地址)相差1


=================================字符串替换 replace_substr()===================================
// 在字符串(src)中找到匹配的子字符串(sub), 然后用另一个字符串(new_sub)替换子字符串(sub), (dst)为输出参数
int replace_substr(char* src, char** dst, char* sub, char* new_sub)
{
	if (src == NULL || dst == NULL || sub == NULL || new_sub == NULL)
	{
		return -1;
	}
	char* start = src;
	char* p = NULL;
	char tmp[512] = { 0 };
	int len = 0;
	do
	{
		p = strstr(start, sub);
		if (p != NULL)
		{
			len = 0;
			len = p - start;
			if (len > 0)
			{
				strncat(tmp, start, len);
			}
			strncat(tmp, new_sub, strlen(new_sub));
			// 重新设置起点位置
			start = p + strlen(sub);
		}
		else
		{
			strcat(tmp, start);
			break;
		}
	} while (*start != '\0');
	// 新字符串要传到主函数中, 所以此子函数调用结束不能释放, 需要在对空间开辟内存空间, 然后由主函数手动释放
	char* buf = (char*)malloc(strlen(tmp) + 1);
	strcpy(buf, tmp);

	// 间接赋值
	*dst = buf;
	return 0;
}

// 调用
int main(){
	char* p = "abcd23424abcd2222abcd888qqqqq";
	char* buf = NULL; // 在replace_substr函数中分配空间
	int ret = 0;
	ret = replace_substr(p, &buf, "abcd", "mmmnnn");
	if (ret != 0)
	{
		printf("replace_substr() error: %d\n", ret);
		return ret;
	}
	printf("p = %s\n", p);
	printf("buf = %s\n", buf);

	if (buf != NULL)
	{
		free(buf);
		buf = NULL;
	}
}


=================================字符串分割/分割字符串 split_string()===================================
// 用一个字符(c)分割字符串(str), 放到数组(buf)中, 并返回数组的长度(n)
int split_string(const char* str, char c, char buf[10][30], int* count)
{
	if (str == NULL || count == NULL)
	{
		return -1;
	}
	// str = "sfjlsf,sfa,abcd,3dedd,sss,aaa"
	const char* start = str;
	char* p = NULL;
	int i = 0;
	do
	{
		p = strchr(start, c);
		if (p != NULL)
		{
			int len = p - start;
			strncpy(buf[i], start, len);
			// 结束符
			buf[i][len] = 0;
			i++;
			// 重新设置起点位置
			start = p + 1;
		}
		else
		{
			strcpy(buf[i], start);
			i++;
			break;
		}
	} while (*start != 0);
	if (i == 0)
	{
		return -2;
	}
	*count = i;
	return 0;
}

// 调用
int main(){
	const char* p = "sfjlsf,sfa,abcd,3dedd,sss,aaa";
	char buf[10][30] = { 0 };
	int n = 0;
	int i = 0;
	int ret = 0;
	ret = split_string(p, ',', buf, &n);
	if (ret != 0)
	{
		printf("split_string() error: %d\n", ret);
		return ret;
	}
	for (i = 0; i < n; i++)
	{
		printf("%s\n", buf[i]);
	}
	printf("\n");
}


=================================数组指针===================================
1.先定义数组类型, 根据类型定义指针变量
typedef int A[10]; // A数组类型
A* p = NULL; // 数组指针类型变量
A a;
p = &a;

2.1 先定义数组指针类型, 根据类型定义变量
// 和指针数组写法 int* a[10]; 很类型  相比多了圆括号
typedef int(*P)[10];
P q; // 数组指针变量q
q = &a;

2.2 int(*q)[10]; // 没有typedef, q是数组指针变量
q = &a;


=================================二维数组数组名===================================
int a[][4] = { 1,2,3,4,5,6,7,8,9,10,11,12 };
a: 代表整个数组, 值是整个数组的首元素 {1,2,3,4} 地址
a+1: 值第二个元素(也是一个数组, 步长为4*4)地址, 等价于&a[1]  **************

*a: a是整个数组的首元素 "{1,2,3,4}" 的地址, *a为取整个地址的首元素 "{1,2,3,4}", 值为它的首元素 "1" 的地址
*(a+1): 整个数组地址加1, 取/代表第二个元素 "{5,6,7,8}", 值为 第二个元素 "{5,6,7,8}" 的首元素"5"的地址, 等价于a[1] ***********

*(a+1) + 1: (a+1)的值代表一级数组的第二个元素的地址,步长4*4, *(a+1)指向一级数组的第二个元素二级数组 "{5,6,7,8}",等价a[1], 值为"{5,6,7,8}"的首元素地址 "5" 的地址, 步长4
(a+1)和*(a+1)值相等, 代表的类型不同, 步长不同
再加1就得到"{5,6,7,8}"第二个元素"6"的地址, 所以*(a+1)+1 相当于 &a[1][1];


=================================二位数组作为形参===================================
1.数组作为形参都会退化为指针
2.重点在于指针的步长一致不一致

int a[][4] = { 1,2,3,4,5,6,7,8,9,10,11,12 }; //二位数组的形参步长取决于二级数组的长度(4)
void print_array(int (*p)[4])






=================================C++ 基础===================================
1. 常量const int a = 10, 在编译期间, 在常量表中添加键值对 "a" => 10, 当代码中遇到"a"的时候, 就会把10取出来, "a"不是存储在内存中开辟的一个变量, 它没有指针, 无法修改
2. 引用: 变量的别名
	int a = 10;
	// int & 使用引用类型数据, re就是a的别名
	// 引用一旦声明, 不可变更, re永远是a的别名
	// 声明的同时必须初始化, 声明之后使用re就相当与使用a
	int & re = a; 

	本质: 常量指针
	int & re = a; 编译器实际上进行的操作-> int* const re = &a;


=================================C++ 内联函数===================================
inline void printAB(int a, int b)
{
    cout << "a = " << a << ", b = " << b << endl;
}
(只有代码比较少的不包含for循环的简单的代码) 加inline使得函数称为inline函数, 由编译器处理, c++编译器直接将函数体插入在函数调用的地方(减少压栈出栈开销)
当函数体的执行开销 远远大于压栈, 跳转和返回所用的开销的时候, 内联将毫无意义



=================================C++ 函数指针===================================
int func(int a, int b){
	cout << "func" << endl;
}
1.定义一种函数类型
typedef int(MY_FUNC)(int, int);

MY_FUNC* fp = NULL;
fp = func;
fp(10,20); // 或者(*fp)(10,20); 

2.定义一个指向这种函数类型的指针类型
typedef int(*MY_FUNC_P)(int, int);

MY_FUNC_P fp2 = NULL;
fp2 = func;
fp2(10,20);

3.
int(*fp3)(int,int) = NULL;
fp3 = func;
fp3(10,20);

=================================C++ 构造函数的初始化列表===================================
class A{
public:
	A(int a){
		cout << "A()..." << endl;
	}
	~A(){
		cout << "~A()..." << endl;
	}
	void printA(){
		cout << "a = " << m_a <<endl;
	}
private:
	int m_a;
}

class B{
public:
	B(A &a1, A &a2, int b):m_a1(a1), m_a2(a2)
	{
		m_b = b;
	}

private:
	int m_b;
	A m_a1;
	A m_a2;
}


=================================C++ new&delete===================================
相对c语言中的malloc和free
new: 在堆区开辟一块空间(存类的对象), 并且调用类的构造函数
delete: 释放堆区的一块空间(类的对象所在内存空间), 并且调用对象的析构函数


=================================C++ 类的静态成员===================================
class A{
    static int a; // 不能在类里面初始化
}
int A::a = 10; // 在类的外面初始化静态成员变量


=================================C++ 友元函数===================================
当一个函数要频繁通过调用一个对象的get,set方法获取对象的某个私有属性, 就会出现频繁的压栈出栈开销, 怎么让这个外部函数直接使用对象的私有字段呢?
解:	在对象所在类的内部将 这个外部函数声明为 该类的友元函数:
	friend double PointDistance(Point& p1, Point& p2); // 声明后: 获取的p1的私有字段x -> p1.getX() 就可以直接写成 p1.x

还可以用同样的方式声明友元类


=================================C++ 操作符重载===================================
加号
Complex c3 = c1 + c2; // 相当于调用函数 Complex operator+(c1, c2);


=================================C++ 对象的方法调用底层实现===================================
=================================C++ const修饰的对象的引用调用成员方法的时候报错===================================
类{
	方法();
}
类 对象 = new 类;

对象.方法() => 实际上是调用：方法(&对象)
其中类中的方法的参数是一个 "类*" 类型, const修饰的对象的引用调用成员方法的时候, 实际传入的是一个 "const 类*" 类型

类{
	对象方法() const;
}
在方法声明和实现后面加上const, 那么“方法”的参数就是一个 “const 类*” 类型



=================================C++ 只能指针===================================
#include <memory>

{
	// 相当于 int* ptr = new int;
	auto_ptr<int> ptr(new int);
	*ptr = 20;
}


=================================C++ 继承/子类内存布局/子类父类的构造函数调用过程===================================
class Student2{
public:
	Student2 Student2(int id, string name, int score): Student(id, name){
		this->score = score;
	}
}
创建子类对象的时候, 先调用父类的构造函数创建一个父类对象A, 然后在调用子类自己的构造方法，完善子类的其他部分B。 "A+B"构成了整个子类对象


=================================C++ 多态/virtual虚方法===================================
现象: 一个基类型的对象A调用了一个方法m(), m()是一个虚方法，所有的子类都重写了方法m(), 对象A里面装的可能是基类的实例也可能是子类的实例, 是哪个类的实例就调用哪个类的方法m();
意义: 随着子类却可以不断的拓展 将这个基类型作为形参的方法可以一直使用

静态联编和动态联编: 程序没有运行的时候 编译器不知道父类指针指向的具体是父类对象还是子类对象 既然指针类型是父类的 编译器默认指针指向父类对象 所以默认会调用父类的成员方法(静态联编)
使用虚方法后就有了多态的现象 多态的发生是动态联编  是在程序执行时判断具体父类指针应该调用的方法


*虚析构函数(析构函数有时候也需要多态的支持): 当一个方法以一个基类(A* a)作为形参, 在函数中, delete a, 那么默认情况下也只会调用A类的析构函数, 如果传进来的实参是一个子类, 那么这个子类对象
在创建的过程中,先调用了父类的构造方法创建了一个父类的对象,在调用子类的构造方法完善了子类其余的部分初始化.
此是delete a的时候默认只会调用A的析构函数,只会释放子类对象中的A的构造函数创建的A对象,不会释放子类自身其余的部分,发生内存泄漏
解决思路就是让"delete a" 的时候发生多态, 方法跟上面一样, 在父类A的析构方法前面加上virtual关键字即可


=================================C++ 多态原理===================================
虚函数表和vptr指针
1.当类中声明虚函数时 编译器会在类中生成一个虚函数表
2.虚函数表是一个存储类成员函数指针的数据结构
3.虚函数表是由编译器自动生成和维护的
4.virtual成员函数会被编译器放入虚函数表中
5.存在虚函数时 每个对象中都有一个指向虚函数表的指针(vptr指针)


=================================C++ 纯虚函数===================================
类似于接口 类似C#中的抽象类 不能实例化
1.virtual double getArea() = 0;
2.如果一个类含有一个类似以上的抽象函数 那么这个类就是一个抽象类
3.抽象类的子类需要重写抽象类中的纯虚函数
4.抽象类作为抽象参数 依然可以实现多态



=================================C++进阶 函数模板===================================
将类型参数化(类似于泛型)

template<class T> // template<typename T>
void mySwap(T& a, T& b){
	T temp = a;
	a = b;
	b = temp;
}

原理: 编译阶段编译器会对模板函数进行两次编译, 第一次编译会正常编译模板函数, 第二次编译阶段根据模板函数调用时候传进去的参数类型, 在当前文件中会额外生成一个对应类型的普通函数
比如调用函数mySwap(1,2), 传进去的是两个整形, 匹配上模板函数, 那么会生成以下具体函数:
void mySwap(int& a, int& b){
	T temp = a;
	a = b;
	b = temp;
}


=================================C++进阶 类模板===================================
template<class T>
class Person{
public:
	Person(T id, T age){
		this->mid = id;
		this->mAge = age;
	}
private:
	T mid;
	T mAge;
}

使用时指定一个类型:
Person<int> p(10,20);


=================================C++进阶 类模板中的静态成员===================================
类模板中的静态成员(比如a)其实属于具体类的, 没有具体类, 静态成员没有意义, 不同的具体类中的静态成员a是不同的

template<class T>
class Person{
public:
	static int a;
}

// 静态成员类外初始化
template<class T> int Person<T>::a = 0;

Person<int> p1, p2, p3;
Person<int> pp1, pp2, pp3;
p1.a = 10;
pp1.a = 100; 
那么p1,p2,p3都是10, pp1, pp2, pp3都是100;


=================================C++进阶 对右值去引用??===================================
一个函数:
void PushBack(T& data){...}

调用函数:
int a = 1;
PushBack(a); //√
PushBack(1); //× 因为无法直接对右值取地址

重载函数void PushBack(T& data)
void PushBack(T&& data){...} // 实现完全一样



=================================C++进阶 类型转换===================================
static_cast			用于内置的数据类型的转换; 转换具有继承关系的对象指针或者引用, 子类型转父类型或者父类型转子类型都可以
	int a = 10;
	char c = static_cast<char>(a);

dynamic_cast		派生类(指针或引用)->基类(指针或引用), 转换前会进行对象类型检查

const_cast			主要对const的转换(增加或者去除变量的const特性给新的变量)

reinterpret_cast	用于没有任何关联之间的转换, 比如一个字符指针转换为一个整形数



=================================C++进阶 异常对象生命周期===================================
情况1: 调用拷贝构造
void func(){
	// 在抛出异常后, 此异常对象不会析构
	throw Exception();
}

void test(){
	try{
	}catch(Exception e){
		// 这里调用拷贝构造将上面func()函数抛出的异常拷贝一份给e, 此函数执行完毕(异常对象catch处理完之后), 上面的func()函数抛出的异常对象和e都会析构
	}
}


情况2: 捕获异常对象引用
void func(){
	// 在抛出异常后, 此异常对象不会析构
	throw Exception();
}

void test(){
	try{
	}catch(Exception& e){
		// 这里不会调用拷贝构造, e就是上面func()函数抛出异常的引用, 此函数执行完毕(异常对象catch处理完之后), 上面func()函数所抛出的异常对象析构
	}
}


情况3: 捕获异常对象指针
void func(){
	// 如果捕获此异常的指针, 那么下面这样构造对象就会在抛出异常后就析构, 那么下面test()中捕获的指针将会是一个野指针, 所以要在堆区开辟异常对象的空间, 手动控制异常对象的生命周期
	// throw Exception();

	throw new Exception();
}

void test(){
	try{
	}catch(Exception* e){
		// TODO: 异常处理

		// 最后手动释放上面func()函数抛出的异常对象
		delete e;
	}
}


=================================C++进阶 标准输出_格式化输出===================================
1.cout << "hello world!" << endl;

2.输出一个字符, 支持链式编程
cout.put('h').put('e').put('l') << endl;

3.写/输出一个字符串(二进制流的输出)
char str[] = "hello world!";
cout.write(str, strlen(str));

4.格式化输出
	4.1 成员方法的方式
	int number = 10;
	cout << number << endl; // 10
	cout.unsetf(ios::dec); // 卸载当前默认的十进制输出方式
	cout.setf(ios::oct); // 八进制输出
	cout.setf(ios::showbase); // 把八进制开头的0显示出来
	cout << number << endl; // 012

	4.2 通过控制符的方式(需要包含头文件: #include <iomanip>)
	int number2 = 10;
	// 0xa~~~~~~~
	cout << hex
		<< setiosflags(ios::showbase)
		<< setw(10)
		<< setfill('~')
		<< setiosflags(ios::left)
		<< number2
		<< endl;


=================================C++进阶 文件读写基本操作===================================
#include <fstream>
// 拷贝文件(包含文件读写的基本操作)
void copy_file() {
	char* file_name = "D:/others.project/clang/zerg/HelloC/HelloC/test_file_io.txt";
	char* target_file_name = "D:/others.project/clang/zerg/HelloC/HelloC/test_file_io_bak.txt";
	ifstream ism(file_name, ios::in); //只读方式打开文件
	ofstream osm(target_file_name, ios::out); //写方式打开文件
	// ofstream osm(target_file_name, ios::out | ios::app); // 追加的方式打开文件,没执行一次程序,都会追加内容
	if (!ism)
	{
		cout << "打开文件失败" << endl;
		return;
	}
	// 读文件
	char ch;
	while (ism.get(ch))
	{
		cout << ch;
		osm.put(ch); // 流写入一个字符
	}
	// 关闭文件
	ism.close();
	osm.close();
}


=================================C++进阶 二进制文件读写(可以将对象保存到文件再从文件读取出对象, 对象是以二进制存在于内存中的)===================================
class Person {
public:
	Person() {}
	Person(int age, int id) :age(age), id(id) {}
	void Show() {
		cout << "Age: " << this->age << " Id: " << this->id << endl;
	}
public:
	int age;
	int id;
};

// 二进制文件读写-对象序列化
void seri_obj_then_save_to_file() {
	// 文本模式读写就是会对换行操作符进行一个转换(windows平台), 在Linux平台文本模式读写和二进制模式读写没有区别
	Person p1(10, 20), p2(30, 40); // 二进制形式存储在内存中
	// 把p1, p2写进文件
	char* target_file_name = "D:/others.project/clang/zerg/HelloC/HelloC/test_file_io_bak.txt";
	ofstream osm(target_file_name, ios::out | ios::binary); // 二进制模式写
	osm.write((char*)&p1, sizeof(Person)); // 二进制方式写文件
	osm.write((char*)&p2, sizeof(Person)); 
	osm.close();
}
void read_binary_file() {
	char* target_file_name = "D:/others.project/clang/zerg/HelloC/HelloC/test_file_io_bak.txt";
	ifstream ism(target_file_name, ios::in | ios::binary);
	Person p1;
	Person p2;
	ism.read((char*)&p1, sizeof(Person)); // 从文件读取数据
	ism.read((char*)&p2, sizeof(Person));	
	p1.Show(); // Age: 10 Id: 20
	p2.Show(); // Age: 30 Id: 40
}















爱,死亡和机器人
自修室
曼达洛人
致命女人
切尔诺贝利









